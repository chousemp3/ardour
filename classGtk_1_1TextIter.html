<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta property="og:title" content="Ardour Source Documentation" />
<meta property="og:image" content="/images/logo.png" />
<meta property="og:description" content="the open source cross-platform DAW" />
<meta property="og:url" content="https://ardour.org/" />
<title>Ardour: Gtk::TextIter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="/images/icons/favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Ardour-icon_48px.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ardour
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classGtk_1_1TextIter.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classGtk_1_1TextIter-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Gtk::TextIter Class Reference<div class="ingroups"><a class="el" href="group__TextView.html">TextView Classes</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="textiter_8h_source.html">textiter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3a01330bff36d513299c97cd3e877181" id="r_a3a01330bff36d513299c97cd3e877181"><td class="memItemLeft" align="right" valign="top">typedef std::bidirectional_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a3a01330bff36d513299c97cd3e877181">iterator_category</a></td></tr>
<tr class="separator:a3a01330bff36d513299c97cd3e877181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f6efe5a5875e7198e3de43c64e2db0" id="r_ae1f6efe5a5875e7198e3de43c64e2db0"><td class="memItemLeft" align="right" valign="top">typedef gunichar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ae1f6efe5a5875e7198e3de43c64e2db0">value_type</a></td></tr>
<tr class="separator:ae1f6efe5a5875e7198e3de43c64e2db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d32cb4ee3ea8790352a473954ddbbd4" id="r_a1d32cb4ee3ea8790352a473954ddbbd4"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a1d32cb4ee3ea8790352a473954ddbbd4">difference_type</a></td></tr>
<tr class="separator:a1d32cb4ee3ea8790352a473954ddbbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c83319eb101749fe43d587a0db45da" id="r_aa0c83319eb101749fe43d587a0db45da"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classGtk_1_1TextIter.html#ae1f6efe5a5875e7198e3de43c64e2db0">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aa0c83319eb101749fe43d587a0db45da">reference</a></td></tr>
<tr class="separator:aa0c83319eb101749fe43d587a0db45da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c43f99b310aee6c53adbd6dd71fe51" id="r_a42c43f99b310aee6c53adbd6dd71fe51"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a42c43f99b310aee6c53adbd6dd71fe51">pointer</a></td></tr>
<tr class="separator:a42c43f99b310aee6c53adbd6dd71fe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a311d1ed5fa8bd0d55d18b743d45bd118" id="r_a311d1ed5fa8bd0d55d18b743d45bd118"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a311d1ed5fa8bd0d55d18b743d45bd118">TextIter</a> ()</td></tr>
<tr class="separator:a311d1ed5fa8bd0d55d18b743d45bd118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac015411ec402d42fe22dfa048a97d7b2" id="r_ac015411ec402d42fe22dfa048a97d7b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ac015411ec402d42fe22dfa048a97d7b2">TextIter</a> (const <a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a> *gobject)</td></tr>
<tr class="separator:ac015411ec402d42fe22dfa048a97d7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb1b33f67670182e42c41f6f257693b" id="r_aeeb1b33f67670182e42c41f6f257693b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aeeb1b33f67670182e42c41f6f257693b">gobj</a> ()</td></tr>
<tr class="memdesc:aeeb1b33f67670182e42c41f6f257693b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance.  <br /></td></tr>
<tr class="separator:aeeb1b33f67670182e42c41f6f257693b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7dc42d4091db4051e625e5c4669bff" id="r_a3f7dc42d4091db4051e625e5c4669bff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a3f7dc42d4091db4051e625e5c4669bff">gobj</a> () const</td></tr>
<tr class="memdesc:a3f7dc42d4091db4051e625e5c4669bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance.  <br /></td></tr>
<tr class="separator:a3f7dc42d4091db4051e625e5c4669bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70482e3c658cb04b6ecad1ab612a9f35" id="r_a70482e3c658cb04b6ecad1ab612a9f35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a70482e3c658cb04b6ecad1ab612a9f35">operator++</a> ()</td></tr>
<tr class="separator:a70482e3c658cb04b6ecad1ab612a9f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27c3a2f0663071f9319fe140f047b72" id="r_ae27c3a2f0663071f9319fe140f047b72"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ae27c3a2f0663071f9319fe140f047b72">operator++</a> (int)</td></tr>
<tr class="separator:ae27c3a2f0663071f9319fe140f047b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e89f081569ca3a79b38ffc54d0bbc3" id="r_ae5e89f081569ca3a79b38ffc54d0bbc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ae5e89f081569ca3a79b38ffc54d0bbc3">operator--</a> ()</td></tr>
<tr class="separator:ae5e89f081569ca3a79b38ffc54d0bbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9050a524dda968db856b3e791fc833d" id="r_ae9050a524dda968db856b3e791fc833d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ae9050a524dda968db856b3e791fc833d">operator--</a> (int)</td></tr>
<tr class="separator:ae9050a524dda968db856b3e791fc833d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945df1c0edb735d27c001d7588b10c70" id="r_a945df1c0edb735d27c001d7588b10c70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html#ae1f6efe5a5875e7198e3de43c64e2db0">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a945df1c0edb735d27c001d7588b10c70">operator*</a> () const</td></tr>
<tr class="separator:a945df1c0edb735d27c001d7588b10c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c9650c64751fe98aa235d9a49326f5" id="r_aa7c9650c64751fe98aa235d9a49326f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aa7c9650c64751fe98aa235d9a49326f5">operator bool</a> () const</td></tr>
<tr class="separator:aa7c9650c64751fe98aa235d9a49326f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f42cc6fc233b4daadab5490297f1334" id="r_a6f42cc6fc233b4daadab5490297f1334"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextBuffer.html">TextBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a6f42cc6fc233b4daadab5490297f1334">get_buffer</a> () const</td></tr>
<tr class="separator:a6f42cc6fc233b4daadab5490297f1334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdd5eb44a819d9ef4bd8d1f71647a2c" id="r_a1fdd5eb44a819d9ef4bd8d1f71647a2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a1fdd5eb44a819d9ef4bd8d1f71647a2c">get_offset</a> () const</td></tr>
<tr class="separator:a1fdd5eb44a819d9ef4bd8d1f71647a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb1fe241ed39c3a7bc3f94d6b63da53" id="r_a3cb1fe241ed39c3a7bc3f94d6b63da53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a3cb1fe241ed39c3a7bc3f94d6b63da53">get_line</a> () const</td></tr>
<tr class="separator:a3cb1fe241ed39c3a7bc3f94d6b63da53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c6ca9348bb89f4e1f614954118f41b" id="r_ad2c6ca9348bb89f4e1f614954118f41b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ad2c6ca9348bb89f4e1f614954118f41b">get_line_offset</a> () const</td></tr>
<tr class="separator:ad2c6ca9348bb89f4e1f614954118f41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8951d3815c0b9634e278cce421b97ad9" id="r_a8951d3815c0b9634e278cce421b97ad9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a8951d3815c0b9634e278cce421b97ad9">get_line_index</a> () const</td></tr>
<tr class="separator:a8951d3815c0b9634e278cce421b97ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f7f08e03d31e2ec644f7d94c6c483f" id="r_a27f7f08e03d31e2ec644f7d94c6c483f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a27f7f08e03d31e2ec644f7d94c6c483f">get_visible_line_offset</a> () const</td></tr>
<tr class="separator:a27f7f08e03d31e2ec644f7d94c6c483f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b82b9e7c687a662aa46c1a8dd987513" id="r_a2b82b9e7c687a662aa46c1a8dd987513"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a2b82b9e7c687a662aa46c1a8dd987513">get_visible_line_index</a> () const</td></tr>
<tr class="separator:a2b82b9e7c687a662aa46c1a8dd987513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4a9e85bc094f7ed798b7b3491ddd92" id="r_acf4a9e85bc094f7ed798b7b3491ddd92"><td class="memItemLeft" align="right" valign="top">gunichar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#acf4a9e85bc094f7ed798b7b3491ddd92">get_char</a> () const</td></tr>
<tr class="separator:acf4a9e85bc094f7ed798b7b3491ddd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de7abe2170a48356a6da445114bc458" id="r_a2de7abe2170a48356a6da445114bc458"><td class="memItemLeft" align="right" valign="top">Glib::ustring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a2de7abe2170a48356a6da445114bc458">get_slice</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;end) const</td></tr>
<tr class="separator:a2de7abe2170a48356a6da445114bc458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8390096614364d86f576244b31c108c" id="r_ae8390096614364d86f576244b31c108c"><td class="memItemLeft" align="right" valign="top">Glib::ustring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ae8390096614364d86f576244b31c108c">get_text</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;end) const</td></tr>
<tr class="separator:ae8390096614364d86f576244b31c108c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49baac63b7a846693f223d6238fd2748" id="r_a49baac63b7a846693f223d6238fd2748"><td class="memItemLeft" align="right" valign="top">Glib::ustring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a49baac63b7a846693f223d6238fd2748">get_visible_slice</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;end) const</td></tr>
<tr class="separator:a49baac63b7a846693f223d6238fd2748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006c1df0a2b4324ccfabd1f62bb1dfc1" id="r_a006c1df0a2b4324ccfabd1f62bb1dfc1"><td class="memItemLeft" align="right" valign="top">Glib::ustring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a006c1df0a2b4324ccfabd1f62bb1dfc1">get_visible_text</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;end) const</td></tr>
<tr class="separator:a006c1df0a2b4324ccfabd1f62bb1dfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232d63bb9d0691fdaa838652e8307580" id="r_a232d63bb9d0691fdaa838652e8307580"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a232d63bb9d0691fdaa838652e8307580">get_pixbuf</a> () const</td></tr>
<tr class="separator:a232d63bb9d0691fdaa838652e8307580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa1d35bc0fe07dfd4c46c1a1935561f" id="r_aafa1d35bc0fe07dfd4c46c1a1935561f"><td class="memItemLeft" align="right" valign="top">Glib::SListHandle&lt; Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextMark.html">TextMark</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aafa1d35bc0fe07dfd4c46c1a1935561f">get_marks</a> ()</td></tr>
<tr class="separator:aafa1d35bc0fe07dfd4c46c1a1935561f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c268ce5a1c7037a2aced64592ff86c" id="r_af3c268ce5a1c7037a2aced64592ff86c"><td class="memItemLeft" align="right" valign="top">Glib::SListHandle&lt; Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextMark.html">TextMark</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#af3c268ce5a1c7037a2aced64592ff86c">get_marks</a> () const</td></tr>
<tr class="separator:af3c268ce5a1c7037a2aced64592ff86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7be1fa66eafad2e64b313c57a9cb886" id="r_ad7be1fa66eafad2e64b313c57a9cb886"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextChildAnchor.html">TextChildAnchor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ad7be1fa66eafad2e64b313c57a9cb886">get_child_anchor</a> ()</td></tr>
<tr class="separator:ad7be1fa66eafad2e64b313c57a9cb886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e020cb7163d423a8ef1621d968b14d2" id="r_a8e020cb7163d423a8ef1621d968b14d2"><td class="memItemLeft" align="right" valign="top">Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextChildAnchor.html">TextChildAnchor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a8e020cb7163d423a8ef1621d968b14d2">get_child_anchor</a> () const</td></tr>
<tr class="separator:a8e020cb7163d423a8ef1621d968b14d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af041478bda20f0e9e3ce655da7205c7c" id="r_af041478bda20f0e9e3ce655da7205c7c"><td class="memItemLeft" align="right" valign="top">Glib::SListHandle&lt; Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#af041478bda20f0e9e3ce655da7205c7c">get_toggled_tags</a> (bool toggled_on=true)</td></tr>
<tr class="separator:af041478bda20f0e9e3ce655da7205c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324910dee0a64465bf56328962c5c375" id="r_a324910dee0a64465bf56328962c5c375"><td class="memItemLeft" align="right" valign="top">Glib::SListHandle&lt; Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a324910dee0a64465bf56328962c5c375">get_toggled_tags</a> (bool toggled_on=true) const</td></tr>
<tr class="separator:a324910dee0a64465bf56328962c5c375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f07a9e1606add1754568c80e4ac1a58" id="r_a3f07a9e1606add1754568c80e4ac1a58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a3f07a9e1606add1754568c80e4ac1a58">begins_tag</a> (const Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;tag) const</td></tr>
<tr class="separator:a3f07a9e1606add1754568c80e4ac1a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5741217aa0478fc2abea8f9429722839" id="r_a5741217aa0478fc2abea8f9429722839"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a5741217aa0478fc2abea8f9429722839">begins_tag</a> () const</td></tr>
<tr class="separator:a5741217aa0478fc2abea8f9429722839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35645f29b1476ce8a7b899d343663e41" id="r_a35645f29b1476ce8a7b899d343663e41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a35645f29b1476ce8a7b899d343663e41">ends_tag</a> (const Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;tag) const</td></tr>
<tr class="separator:a35645f29b1476ce8a7b899d343663e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea455127c3147b71ae88665aab53a4f" id="r_a0ea455127c3147b71ae88665aab53a4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a0ea455127c3147b71ae88665aab53a4f">ends_tag</a> () const</td></tr>
<tr class="separator:a0ea455127c3147b71ae88665aab53a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7e890f7a6cb3003c485e36b8eaad59" id="r_a0e7e890f7a6cb3003c485e36b8eaad59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a0e7e890f7a6cb3003c485e36b8eaad59">toggles_tag</a> (const Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;tag) const</td></tr>
<tr class="separator:a0e7e890f7a6cb3003c485e36b8eaad59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbe15539dfb50119b5b28b2155208c6" id="r_a5bbe15539dfb50119b5b28b2155208c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a5bbe15539dfb50119b5b28b2155208c6">toggles_tag</a> () const</td></tr>
<tr class="separator:a5bbe15539dfb50119b5b28b2155208c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7014ff418003017a0b1d5a9f18c35599" id="r_a7014ff418003017a0b1d5a9f18c35599"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a7014ff418003017a0b1d5a9f18c35599">has_tag</a> (const Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;tag) const</td></tr>
<tr class="separator:a7014ff418003017a0b1d5a9f18c35599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802c12f54bd8e1aaaa7fad5e77ed79d5" id="r_a802c12f54bd8e1aaaa7fad5e77ed79d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a802c12f54bd8e1aaaa7fad5e77ed79d5">has_tag</a> () const</td></tr>
<tr class="separator:a802c12f54bd8e1aaaa7fad5e77ed79d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba16544194fa61ada320c6c580d15d8" id="r_a7ba16544194fa61ada320c6c580d15d8"><td class="memItemLeft" align="right" valign="top">Glib::SListHandle&lt; Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a7ba16544194fa61ada320c6c580d15d8">get_tags</a> ()</td></tr>
<tr class="separator:a7ba16544194fa61ada320c6c580d15d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb78901b3e0dbee26c2fae2c98ec0f6e" id="r_afb78901b3e0dbee26c2fae2c98ec0f6e"><td class="memItemLeft" align="right" valign="top">Glib::SListHandle&lt; Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#afb78901b3e0dbee26c2fae2c98ec0f6e">get_tags</a> () const</td></tr>
<tr class="separator:afb78901b3e0dbee26c2fae2c98ec0f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabdbb0fe11b79e0bb3e6c95eb7e60ac" id="r_acabdbb0fe11b79e0bb3e6c95eb7e60ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#acabdbb0fe11b79e0bb3e6c95eb7e60ac">editable</a> (bool default_setting=true) const</td></tr>
<tr class="separator:acabdbb0fe11b79e0bb3e6c95eb7e60ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a4db2657260da865de31cddd3a76da" id="r_a06a4db2657260da865de31cddd3a76da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a06a4db2657260da865de31cddd3a76da">can_insert</a> (bool default_editability=true) const</td></tr>
<tr class="separator:a06a4db2657260da865de31cddd3a76da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd81e0a2658984f1bce0e2ce84121a6" id="r_a1dd81e0a2658984f1bce0e2ce84121a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a1dd81e0a2658984f1bce0e2ce84121a6">starts_word</a> () const</td></tr>
<tr class="separator:a1dd81e0a2658984f1bce0e2ce84121a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d680c52f36b84500340a3c5d848b9a" id="r_a34d680c52f36b84500340a3c5d848b9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a34d680c52f36b84500340a3c5d848b9a">ends_word</a> () const</td></tr>
<tr class="separator:a34d680c52f36b84500340a3c5d848b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd86e2f7c6587a160d55530539a64e3" id="r_a3cd86e2f7c6587a160d55530539a64e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a3cd86e2f7c6587a160d55530539a64e3">inside_word</a> () const</td></tr>
<tr class="separator:a3cd86e2f7c6587a160d55530539a64e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217523e50116ccaf23d276f422747d06" id="r_a217523e50116ccaf23d276f422747d06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a217523e50116ccaf23d276f422747d06">starts_sentence</a> () const</td></tr>
<tr class="separator:a217523e50116ccaf23d276f422747d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771764060ebee507f9f846404ef13d31" id="r_a771764060ebee507f9f846404ef13d31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a771764060ebee507f9f846404ef13d31">ends_sentence</a> () const</td></tr>
<tr class="separator:a771764060ebee507f9f846404ef13d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ece7b7eb8f963efef648ed23f6c99fc" id="r_a6ece7b7eb8f963efef648ed23f6c99fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a6ece7b7eb8f963efef648ed23f6c99fc">inside_sentence</a> () const</td></tr>
<tr class="separator:a6ece7b7eb8f963efef648ed23f6c99fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30723ef87da296d9033fc7f85792199" id="r_ad30723ef87da296d9033fc7f85792199"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ad30723ef87da296d9033fc7f85792199">starts_line</a> () const</td></tr>
<tr class="separator:ad30723ef87da296d9033fc7f85792199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa858e906ce5d54740b6034c9e916fa8e" id="r_aa858e906ce5d54740b6034c9e916fa8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aa858e906ce5d54740b6034c9e916fa8e">ends_line</a> () const</td></tr>
<tr class="separator:aa858e906ce5d54740b6034c9e916fa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a307c658ba6004d08a3d448852187b" id="r_a03a307c658ba6004d08a3d448852187b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a03a307c658ba6004d08a3d448852187b">is_cursor_position</a> () const</td></tr>
<tr class="separator:a03a307c658ba6004d08a3d448852187b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2a73293b9fc58fcb2ccb7f6b819012" id="r_a7d2a73293b9fc58fcb2ccb7f6b819012"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a7d2a73293b9fc58fcb2ccb7f6b819012">get_chars_in_line</a> () const</td></tr>
<tr class="separator:a7d2a73293b9fc58fcb2ccb7f6b819012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9c9c23869934ea6ea27079b7f4f77f" id="r_adc9c9c23869934ea6ea27079b7f4f77f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#adc9c9c23869934ea6ea27079b7f4f77f">get_bytes_in_line</a> () const</td></tr>
<tr class="separator:adc9c9c23869934ea6ea27079b7f4f77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55f93e8895ea4257ad9bfe38c1fd530" id="r_aa55f93e8895ea4257ad9bfe38c1fd530"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aa55f93e8895ea4257ad9bfe38c1fd530">get_attributes</a> (<a class="el" href="classGtk_1_1TextAttributes.html">TextAttributes</a> &amp;values) const</td></tr>
<tr class="separator:aa55f93e8895ea4257ad9bfe38c1fd530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a90a51fc27c4f9a46380e02b9cb3a6c" id="r_a5a90a51fc27c4f9a46380e02b9cb3a6c"><td class="memItemLeft" align="right" valign="top">Pango::Language&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a5a90a51fc27c4f9a46380e02b9cb3a6c">get_language</a> () const</td></tr>
<tr class="separator:a5a90a51fc27c4f9a46380e02b9cb3a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc622b76b6d149cc8c162bea7f8a1ad" id="r_a4bc622b76b6d149cc8c162bea7f8a1ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a4bc622b76b6d149cc8c162bea7f8a1ad">is_end</a> () const</td></tr>
<tr class="separator:a4bc622b76b6d149cc8c162bea7f8a1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc36f98cd9d69a4afc6f89ba58808cbd" id="r_adc36f98cd9d69a4afc6f89ba58808cbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#adc36f98cd9d69a4afc6f89ba58808cbd">is_start</a> () const</td></tr>
<tr class="separator:adc36f98cd9d69a4afc6f89ba58808cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46acea844c69273d92c63d910eca21c9" id="r_a46acea844c69273d92c63d910eca21c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a46acea844c69273d92c63d910eca21c9">forward_char</a> ()</td></tr>
<tr class="separator:a46acea844c69273d92c63d910eca21c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff64dab2ff97e06452f4ca7c030b758" id="r_aeff64dab2ff97e06452f4ca7c030b758"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aeff64dab2ff97e06452f4ca7c030b758">backward_char</a> ()</td></tr>
<tr class="separator:aeff64dab2ff97e06452f4ca7c030b758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbab55d587698d0f51776faa0cc2a43" id="r_aadbab55d587698d0f51776faa0cc2a43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aadbab55d587698d0f51776faa0cc2a43">forward_chars</a> (int count)</td></tr>
<tr class="separator:aadbab55d587698d0f51776faa0cc2a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4020a5193148a459dcf24bb2bc829870" id="r_a4020a5193148a459dcf24bb2bc829870"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a4020a5193148a459dcf24bb2bc829870">backward_chars</a> (int count)</td></tr>
<tr class="separator:a4020a5193148a459dcf24bb2bc829870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8832f0168bbcf8651cff1eb632f13f" id="r_aca8832f0168bbcf8651cff1eb632f13f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aca8832f0168bbcf8651cff1eb632f13f">forward_line</a> ()</td></tr>
<tr class="separator:aca8832f0168bbcf8651cff1eb632f13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695ab83b6fbffa39496959a4f9a5eece" id="r_a695ab83b6fbffa39496959a4f9a5eece"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a695ab83b6fbffa39496959a4f9a5eece">backward_line</a> ()</td></tr>
<tr class="separator:a695ab83b6fbffa39496959a4f9a5eece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb054a9ee7862010ad5564571bda2552" id="r_adb054a9ee7862010ad5564571bda2552"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#adb054a9ee7862010ad5564571bda2552">forward_lines</a> (int count)</td></tr>
<tr class="separator:adb054a9ee7862010ad5564571bda2552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9e763fe2fd18f11a4156820f39bb9b" id="r_a8a9e763fe2fd18f11a4156820f39bb9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a8a9e763fe2fd18f11a4156820f39bb9b">backward_lines</a> (int count)</td></tr>
<tr class="separator:a8a9e763fe2fd18f11a4156820f39bb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bba655ab512cf1569590d9206d797b" id="r_a05bba655ab512cf1569590d9206d797b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a05bba655ab512cf1569590d9206d797b">forward_word_end</a> ()</td></tr>
<tr class="separator:a05bba655ab512cf1569590d9206d797b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8136c917007d6a4a7c7969221410d2" id="r_a8f8136c917007d6a4a7c7969221410d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a8f8136c917007d6a4a7c7969221410d2">backward_word_start</a> ()</td></tr>
<tr class="separator:a8f8136c917007d6a4a7c7969221410d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d74cb53546701ec0b42266ac40e2a1" id="r_aa7d74cb53546701ec0b42266ac40e2a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aa7d74cb53546701ec0b42266ac40e2a1">forward_word_ends</a> (int count)</td></tr>
<tr class="separator:aa7d74cb53546701ec0b42266ac40e2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f5b1eeec69bdd6443b75a659407dd8" id="r_a14f5b1eeec69bdd6443b75a659407dd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a14f5b1eeec69bdd6443b75a659407dd8">backward_word_starts</a> (int count)</td></tr>
<tr class="separator:a14f5b1eeec69bdd6443b75a659407dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506be5cb9d7dd29522b71cddd520bda3" id="r_a506be5cb9d7dd29522b71cddd520bda3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a506be5cb9d7dd29522b71cddd520bda3">forward_visible_line</a> ()</td></tr>
<tr class="separator:a506be5cb9d7dd29522b71cddd520bda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d52ce38268847ed46cefca328b478cd" id="r_a2d52ce38268847ed46cefca328b478cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a2d52ce38268847ed46cefca328b478cd">backward_visible_line</a> ()</td></tr>
<tr class="separator:a2d52ce38268847ed46cefca328b478cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a295c7dead80d24470f33a67a6dd74" id="r_a55a295c7dead80d24470f33a67a6dd74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a55a295c7dead80d24470f33a67a6dd74">forward_visible_line</a> (int count)</td></tr>
<tr class="separator:a55a295c7dead80d24470f33a67a6dd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435bac2e52fac10cbd4c5175fcc6893c" id="r_a435bac2e52fac10cbd4c5175fcc6893c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a435bac2e52fac10cbd4c5175fcc6893c">backward_visible_lines</a> (int count)</td></tr>
<tr class="separator:a435bac2e52fac10cbd4c5175fcc6893c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79bd3e6c8cd7ccdc45b8ed8064986e8" id="r_ac79bd3e6c8cd7ccdc45b8ed8064986e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ac79bd3e6c8cd7ccdc45b8ed8064986e8">forward_visible_word_end</a> ()</td></tr>
<tr class="separator:ac79bd3e6c8cd7ccdc45b8ed8064986e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1afad7efe043ebf9f8c8a0aa6b8034" id="r_a9e1afad7efe043ebf9f8c8a0aa6b8034"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a9e1afad7efe043ebf9f8c8a0aa6b8034">backward_visible_word_start</a> ()</td></tr>
<tr class="separator:a9e1afad7efe043ebf9f8c8a0aa6b8034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a7521c3392d07d24790702433cd1ff" id="r_ad9a7521c3392d07d24790702433cd1ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ad9a7521c3392d07d24790702433cd1ff">forward_visible_word_ends</a> (int count)</td></tr>
<tr class="separator:ad9a7521c3392d07d24790702433cd1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432ef8da68c876335cb020e24b5880d4" id="r_a432ef8da68c876335cb020e24b5880d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a432ef8da68c876335cb020e24b5880d4">backward_visible_word_starts</a> (int count)</td></tr>
<tr class="separator:a432ef8da68c876335cb020e24b5880d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1c3dc0fa3c7545e6a09aa082e4032e" id="r_a2d1c3dc0fa3c7545e6a09aa082e4032e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a2d1c3dc0fa3c7545e6a09aa082e4032e">forward_sentence_end</a> ()</td></tr>
<tr class="separator:a2d1c3dc0fa3c7545e6a09aa082e4032e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0855474df38a9084db2cec9171140a" id="r_a7e0855474df38a9084db2cec9171140a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a7e0855474df38a9084db2cec9171140a">backward_sentence_start</a> ()</td></tr>
<tr class="separator:a7e0855474df38a9084db2cec9171140a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aef31e21147f939af5f34ef930f16bf" id="r_a6aef31e21147f939af5f34ef930f16bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a6aef31e21147f939af5f34ef930f16bf">forward_sentence_ends</a> (int count)</td></tr>
<tr class="separator:a6aef31e21147f939af5f34ef930f16bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86618c5b23bebc739057651aded7751a" id="r_a86618c5b23bebc739057651aded7751a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a86618c5b23bebc739057651aded7751a">backward_sentence_starts</a> (int count)</td></tr>
<tr class="separator:a86618c5b23bebc739057651aded7751a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43e1833c36390271f139096f2246684" id="r_ac43e1833c36390271f139096f2246684"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ac43e1833c36390271f139096f2246684">forward_cursor_position</a> ()</td></tr>
<tr class="separator:ac43e1833c36390271f139096f2246684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a84e76bdbf9c60b214c964a47907d0" id="r_ac8a84e76bdbf9c60b214c964a47907d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ac8a84e76bdbf9c60b214c964a47907d0">backward_cursor_position</a> ()</td></tr>
<tr class="separator:ac8a84e76bdbf9c60b214c964a47907d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b20683d7513dfb331bb0a1aeffa63c5" id="r_a8b20683d7513dfb331bb0a1aeffa63c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a8b20683d7513dfb331bb0a1aeffa63c5">forward_cursor_positions</a> (int count)</td></tr>
<tr class="separator:a8b20683d7513dfb331bb0a1aeffa63c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cd242a69337fdbd712dfa784f2d494" id="r_a06cd242a69337fdbd712dfa784f2d494"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a06cd242a69337fdbd712dfa784f2d494">backward_cursor_positions</a> (int count)</td></tr>
<tr class="separator:a06cd242a69337fdbd712dfa784f2d494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647f1e0b30b3ad9470d67f8d42108d6a" id="r_a647f1e0b30b3ad9470d67f8d42108d6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a647f1e0b30b3ad9470d67f8d42108d6a">forward_visible_cursor_position</a> ()</td></tr>
<tr class="separator:a647f1e0b30b3ad9470d67f8d42108d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff24ef7f2c58692eb320365cd0d8001" id="r_a3ff24ef7f2c58692eb320365cd0d8001"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a3ff24ef7f2c58692eb320365cd0d8001">backward_visible_cursor_position</a> ()</td></tr>
<tr class="separator:a3ff24ef7f2c58692eb320365cd0d8001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770ab9cd1f2dd86d586567cb19f8d9a4" id="r_a770ab9cd1f2dd86d586567cb19f8d9a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a770ab9cd1f2dd86d586567cb19f8d9a4">forward_visible_cursor_positions</a> (int count)</td></tr>
<tr class="separator:a770ab9cd1f2dd86d586567cb19f8d9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455e4560fbd1fa19a6f8caea4348255f" id="r_a455e4560fbd1fa19a6f8caea4348255f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a455e4560fbd1fa19a6f8caea4348255f">backward_visible_cursor_positions</a> (int count)</td></tr>
<tr class="separator:a455e4560fbd1fa19a6f8caea4348255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ce173ce4d3622cc36e48d5bff2374f" id="r_a00ce173ce4d3622cc36e48d5bff2374f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a00ce173ce4d3622cc36e48d5bff2374f">set_offset</a> (int char_offset)</td></tr>
<tr class="separator:a00ce173ce4d3622cc36e48d5bff2374f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfba7a50f3ec781d151cc5643e1b4083" id="r_abfba7a50f3ec781d151cc5643e1b4083"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#abfba7a50f3ec781d151cc5643e1b4083">set_line</a> (int line_number)</td></tr>
<tr class="separator:abfba7a50f3ec781d151cc5643e1b4083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c90b4327191537170c796a23d06b25" id="r_a62c90b4327191537170c796a23d06b25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a62c90b4327191537170c796a23d06b25">set_line_offset</a> (int char_on_line)</td></tr>
<tr class="separator:a62c90b4327191537170c796a23d06b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63b8c2520413efdde54dd8ad5670579" id="r_af63b8c2520413efdde54dd8ad5670579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#af63b8c2520413efdde54dd8ad5670579">set_line_index</a> (int byte_on_line)</td></tr>
<tr class="separator:af63b8c2520413efdde54dd8ad5670579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70abfc30933f0e8dec3f014128443dc4" id="r_a70abfc30933f0e8dec3f014128443dc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a70abfc30933f0e8dec3f014128443dc4">forward_to_end</a> ()</td></tr>
<tr class="separator:a70abfc30933f0e8dec3f014128443dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f8195cab1810e35b88122d2ebd7b90" id="r_a31f8195cab1810e35b88122d2ebd7b90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a31f8195cab1810e35b88122d2ebd7b90">forward_to_line_end</a> ()</td></tr>
<tr class="separator:a31f8195cab1810e35b88122d2ebd7b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccd69e5353e073ce841ff0e02ac6a7e" id="r_a7ccd69e5353e073ce841ff0e02ac6a7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a7ccd69e5353e073ce841ff0e02ac6a7e">set_visible_line_offset</a> (int char_on_line)</td></tr>
<tr class="separator:a7ccd69e5353e073ce841ff0e02ac6a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b3039e099a9c3d752b8a3809d1ae4d" id="r_a40b3039e099a9c3d752b8a3809d1ae4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a40b3039e099a9c3d752b8a3809d1ae4d">set_visible_line_index</a> (int byte_on_line)</td></tr>
<tr class="separator:a40b3039e099a9c3d752b8a3809d1ae4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b4fc66df6e0b9b8046c2f70b261629" id="r_a89b4fc66df6e0b9b8046c2f70b261629"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a89b4fc66df6e0b9b8046c2f70b261629">forward_to_tag_toggle</a> (const Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;tag)</td></tr>
<tr class="separator:a89b4fc66df6e0b9b8046c2f70b261629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17e2abaf014a0796ad7c668ca378d58" id="r_ad17e2abaf014a0796ad7c668ca378d58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ad17e2abaf014a0796ad7c668ca378d58">backward_to_tag_toggle</a> (const Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;tag)</td></tr>
<tr class="separator:ad17e2abaf014a0796ad7c668ca378d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d514e9a2cb99e547426dce3653949c" id="r_a12d514e9a2cb99e547426dce3653949c"><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a12d514e9a2cb99e547426dce3653949c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a12d514e9a2cb99e547426dce3653949c">forward_find_char</a> (const Predicate &amp;predicate, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;limit)</td></tr>
<tr class="separator:a12d514e9a2cb99e547426dce3653949c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e72a44551eb03237a0c9919cebdf371" id="r_a1e72a44551eb03237a0c9919cebdf371"><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a1e72a44551eb03237a0c9919cebdf371"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a1e72a44551eb03237a0c9919cebdf371">forward_find_char</a> (const Predicate &amp;predicate)</td></tr>
<tr class="separator:a1e72a44551eb03237a0c9919cebdf371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15dfc2cae642743f48d54283664ed44" id="r_ad15dfc2cae642743f48d54283664ed44"><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:ad15dfc2cae642743f48d54283664ed44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ad15dfc2cae642743f48d54283664ed44">backward_find_char</a> (const Predicate &amp;predicate, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;limit)</td></tr>
<tr class="separator:ad15dfc2cae642743f48d54283664ed44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f09749e194df4bf3c1841cc69efa7c6" id="r_a9f09749e194df4bf3c1841cc69efa7c6"><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a9f09749e194df4bf3c1841cc69efa7c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a9f09749e194df4bf3c1841cc69efa7c6">backward_find_char</a> (const Predicate &amp;predicate)</td></tr>
<tr class="separator:a9f09749e194df4bf3c1841cc69efa7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be0a5bcccde0a25b5814e90c6b6bd71" id="r_a3be0a5bcccde0a25b5814e90c6b6bd71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a3be0a5bcccde0a25b5814e90c6b6bd71">forward_search</a> (const Glib::ustring &amp;str, <a class="el" href="group__gtkmmEnums.html#ga45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a> flags, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;match_start, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;match_end, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;limit) const</td></tr>
<tr class="separator:a3be0a5bcccde0a25b5814e90c6b6bd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32b69adde44a214857d8e8a5bb7ed4a" id="r_aa32b69adde44a214857d8e8a5bb7ed4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aa32b69adde44a214857d8e8a5bb7ed4a">forward_search</a> (const Glib::ustring &amp;str, <a class="el" href="group__gtkmmEnums.html#ga45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a> flags, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;match_start, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;match_end) const</td></tr>
<tr class="separator:aa32b69adde44a214857d8e8a5bb7ed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a40c08f1ebe2fdbfba0a438b07dd916" id="r_a4a40c08f1ebe2fdbfba0a438b07dd916"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a4a40c08f1ebe2fdbfba0a438b07dd916">backward_search</a> (const Glib::ustring &amp;str, <a class="el" href="group__gtkmmEnums.html#ga45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a> flags, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;match_start, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;match_end, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;limit) const</td></tr>
<tr class="separator:a4a40c08f1ebe2fdbfba0a438b07dd916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae928b83540d864698b26264d44f7d4a8" id="r_ae928b83540d864698b26264d44f7d4a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ae928b83540d864698b26264d44f7d4a8">backward_search</a> (const Glib::ustring &amp;str, <a class="el" href="group__gtkmmEnums.html#ga45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a> flags, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;match_start, <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;match_end) const</td></tr>
<tr class="separator:ae928b83540d864698b26264d44f7d4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef515c327715f80fd35355c075d8f120" id="r_aef515c327715f80fd35355c075d8f120"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aef515c327715f80fd35355c075d8f120">compare</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;rhs) const</td></tr>
<tr class="separator:aef515c327715f80fd35355c075d8f120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca810ca092905f0cc728f028be5a2f02" id="r_aca810ca092905f0cc728f028be5a2f02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#aca810ca092905f0cc728f028be5a2f02">in_range</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;start, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;end) const</td></tr>
<tr class="separator:aca810ca092905f0cc728f028be5a2f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3c25edf1efe92f5313ac740781238b" id="r_a4d3c25edf1efe92f5313ac740781238b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a4d3c25edf1efe92f5313ac740781238b">order</a> (<a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;second)</td></tr>
<tr class="separator:a4d3c25edf1efe92f5313ac740781238b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab57cf6632e541c259536162fb9047f66" id="r_ab57cf6632e541c259536162fb9047f66"><td class="memItemLeft" align="right" valign="top">static GType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ab57cf6632e541c259536162fb9047f66">get_type</a> () G_GNUC_CONST</td></tr>
<tr class="separator:ab57cf6632e541c259536162fb9047f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a533d80230ee6366bc575bed7369f4afb" id="r_a533d80230ee6366bc575bed7369f4afb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a533d80230ee6366bc575bed7369f4afb">gobject_</a></td></tr>
<tr class="separator:a533d80230ee6366bc575bed7369f4afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(<a class="el" href="classNote.html">Note</a> that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a8703a159b88dc5e8dd8d4ea361667281" id="r_a8703a159b88dc5e8dd8d4ea361667281"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a8703a159b88dc5e8dd8d4ea361667281">operator==</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;rhs)</td></tr>
<tr class="separator:a8703a159b88dc5e8dd8d4ea361667281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e373b53b974fbab36b1d45ebd206c76" id="r_a0e373b53b974fbab36b1d45ebd206c76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a0e373b53b974fbab36b1d45ebd206c76">operator!=</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;rhs)</td></tr>
<tr class="separator:a0e373b53b974fbab36b1d45ebd206c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdd13320f231bd906520131cdc138d2" id="r_a1cdd13320f231bd906520131cdc138d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a1cdd13320f231bd906520131cdc138d2">operator&lt;</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;rhs)</td></tr>
<tr class="separator:a1cdd13320f231bd906520131cdc138d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50c7c8990fac0c51ac460034ff5f3c4" id="r_ad50c7c8990fac0c51ac460034ff5f3c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#ad50c7c8990fac0c51ac460034ff5f3c4">operator&gt;</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;rhs)</td></tr>
<tr class="separator:ad50c7c8990fac0c51ac460034ff5f3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f0b1315ba7b06bbdfbdd2e029bda73" id="r_a76f0b1315ba7b06bbdfbdd2e029bda73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a76f0b1315ba7b06bbdfbdd2e029bda73">operator&lt;=</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;rhs)</td></tr>
<tr class="separator:a76f0b1315ba7b06bbdfbdd2e029bda73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387ff6ec0c707b3a30ea7398cdc601d2" id="r_a387ff6ec0c707b3a30ea7398cdc601d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a387ff6ec0c707b3a30ea7398cdc601d2">operator&gt;=</a> (const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;lhs, const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;rhs)</td></tr>
<tr class="separator:a387ff6ec0c707b3a30ea7398cdc601d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5497a6a3458131b32c6aaa0fcab3f511" id="r_a5497a6a3458131b32c6aaa0fcab3f511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtk_1_1TextIter.html">Gtk::TextIter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a5497a6a3458131b32c6aaa0fcab3f511">wrap</a> (<a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a> *object)</td></tr>
<tr class="separator:a5497a6a3458131b32c6aaa0fcab3f511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d77ba6925f3144ad49e36412791b7aa" id="r_a5d77ba6925f3144ad49e36412791b7aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classGtk_1_1TextIter.html">Gtk::TextIter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TextIter.html#a5d77ba6925f3144ad49e36412791b7aa">wrap</a> (const <a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a> *object)</td></tr>
<tr class="separator:a5d77ba6925f3144ad49e36412791b7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Typefed as <a class="el" href="classGtk_1_1TextBuffer.html#abb8a8a5abd18b84218e12a4678dcc3c0">Gtk::TextBuffer::iterator</a>. An iterator represents a position between two characters in the text buffer. Iterators are not valid indefinitely; whenever the buffer is modified in a way that affects the number of characters in the buffer, all outstanding iterators become invalid. (<a class="el" href="classNote.html">Note</a> that deleting 5 characters and then reinserting 5 still invalidates iterators, though you end up with the same number of characters you pass through a state with a different number).</p>
<p>Because of this, iterators can't be used to preserve positions across buffer modifications. To preserve a position, the <a class="el" href="classGtk_1_1TextMark.html">Gtk::TextBuffer::Mark</a> object is ideal.</p>
<p>You can iterate over characters, words, lines, and sentences, but <a class="el" href="classGtk_1_1TextIter.html#a945df1c0edb735d27c001d7588b10c70">operator*()</a> and <a class="el" href="classGtk_1_1TextIter.html#a70482e3c658cb04b6ecad1ab612a9f35">operator++()</a> deal only in characters. </p>

<p class="definition">Definition at line <a class="el" href="textiter_8h_source.html#l00129">129</a> of file <a class="el" href="textiter_8h_source.html">textiter.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1d32cb4ee3ea8790352a473954ddbbd4" name="a1d32cb4ee3ea8790352a473954ddbbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d32cb4ee3ea8790352a473954ddbbd4">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="classGtk_1_1TextIter.html#a1d32cb4ee3ea8790352a473954ddbbd4">Gtk::TextIter::difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="textiter_8h_source.html#l00160">160</a> of file <a class="el" href="textiter_8h_source.html">textiter.h</a>.</p>

</div>
</div>
<a id="a3a01330bff36d513299c97cd3e877181" name="a3a01330bff36d513299c97cd3e877181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a01330bff36d513299c97cd3e877181">&#9670;&#160;</a></span>iterator_category</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::bidirectional_iterator_tag <a class="el" href="classGtk_1_1TextIter.html#a3a01330bff36d513299c97cd3e877181">Gtk::TextIter::iterator_category</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="textiter_8h_source.html#l00158">158</a> of file <a class="el" href="textiter_8h_source.html">textiter.h</a>.</p>

</div>
</div>
<a id="a42c43f99b310aee6c53adbd6dd71fe51" name="a42c43f99b310aee6c53adbd6dd71fe51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c43f99b310aee6c53adbd6dd71fe51">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="classGtk_1_1TextIter.html#a42c43f99b310aee6c53adbd6dd71fe51">Gtk::TextIter::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="textiter_8h_source.html#l00162">162</a> of file <a class="el" href="textiter_8h_source.html">textiter.h</a>.</p>

</div>
</div>
<a id="aa0c83319eb101749fe43d587a0db45da" name="aa0c83319eb101749fe43d587a0db45da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c83319eb101749fe43d587a0db45da">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classGtk_1_1TextIter.html#ae1f6efe5a5875e7198e3de43c64e2db0">value_type</a> <a class="el" href="classGtk_1_1TextIter.html#aa0c83319eb101749fe43d587a0db45da">Gtk::TextIter::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="textiter_8h_source.html#l00161">161</a> of file <a class="el" href="textiter_8h_source.html">textiter.h</a>.</p>

</div>
</div>
<a id="ae1f6efe5a5875e7198e3de43c64e2db0" name="ae1f6efe5a5875e7198e3de43c64e2db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f6efe5a5875e7198e3de43c64e2db0">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef gunichar <a class="el" href="classGtk_1_1TextIter.html#ae1f6efe5a5875e7198e3de43c64e2db0">Gtk::TextIter::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="textiter_8h_source.html#l00159">159</a> of file <a class="el" href="textiter_8h_source.html">textiter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a311d1ed5fa8bd0d55d18b743d45bd118" name="a311d1ed5fa8bd0d55d18b743d45bd118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311d1ed5fa8bd0d55d18b743d45bd118">&#9670;&#160;</a></span>TextIter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gtk::TextIter::TextIter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac015411ec402d42fe22dfa048a97d7b2" name="ac015411ec402d42fe22dfa048a97d7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac015411ec402d42fe22dfa048a97d7b2">&#9670;&#160;</a></span>TextIter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gtk::TextIter::TextIter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a> *&#160;</td>
          <td class="paramname"><em>gobject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeff64dab2ff97e06452f4ca7c030b758" name="aeff64dab2ff97e06452f4ca7c030b758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff64dab2ff97e06452f4ca7c030b758">&#9670;&#160;</a></span>backward_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_char </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves backward by one character offset. Returns <code>true</code> if movement was possible; if <em>iter</em> was the first in the buffer (character offset 0), <a class="el" href="classGtk_1_1TextIter.html#aeff64dab2ff97e06452f4ca7c030b758">backward_char()</a> returns <code>false</code> for convenience when writing loops.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether movement was possible. </dd></dl>

</div>
</div>
<a id="a4020a5193148a459dcf24bb2bc829870" name="a4020a5193148a459dcf24bb2bc829870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4020a5193148a459dcf24bb2bc829870">&#9670;&#160;</a></span>backward_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_chars </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>count</em> characters backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of characters to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a id="ac8a84e76bdbf9c60b214c964a47907d0" name="ac8a84e76bdbf9c60b214c964a47907d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a84e76bdbf9c60b214c964a47907d0">&#9670;&#160;</a></span>backward_cursor_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_cursor_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="classGtk_1_1TextIter.html#ac43e1833c36390271f139096f2246684">forward_cursor_position()</a>, but moves backward.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved. </dd></dl>

</div>
</div>
<a id="a06cd242a69337fdbd712dfa784f2d494" name="a06cd242a69337fdbd712dfa784f2d494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cd242a69337fdbd712dfa784f2d494">&#9670;&#160;</a></span>backward_cursor_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_cursor_positions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves up to <em>count</em> cursor positions. See <a class="el" href="classGtk_1_1TextIter.html#ac43e1833c36390271f139096f2246684">forward_cursor_position()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of positions to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a id="a9f09749e194df4bf3c1841cc69efa7c6" name="a9f09749e194df4bf3c1841cc69efa7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f09749e194df4bf3c1841cc69efa7c6">&#9670;&#160;</a></span>backward_find_char() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_find_char </td>
          <td>(</td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad15dfc2cae642743f48d54283664ed44" name="ad15dfc2cae642743f48d54283664ed44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15dfc2cae642743f48d54283664ed44">&#9670;&#160;</a></span>backward_find_char() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_find_char </td>
          <td>(</td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a695ab83b6fbffa39496959a4f9a5eece" name="a695ab83b6fbffa39496959a4f9a5eece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695ab83b6fbffa39496959a4f9a5eece">&#9670;&#160;</a></span>backward_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>iter</em> to the start of the previous line. Returns <code>true</code> if <em>iter</em> could be moved; i.e. if <em>iter</em> was at character offset 0, this function returns <code>false</code>. Therefore if <em>iter</em> was already on line 0, but not at the start of the line, <em>iter</em> is snapped to the start of the line and the function returns <code>true</code>. (<a class="el" href="classNote.html">Note</a> that this implies that in a loop calling this function, the line number may not change on every iteration, if your first iteration is on line 0.)</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved. </dd></dl>

</div>
</div>
<a id="a8a9e763fe2fd18f11a4156820f39bb9b" name="a8a9e763fe2fd18f11a4156820f39bb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9e763fe2fd18f11a4156820f39bb9b">&#9670;&#160;</a></span>backward_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_lines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>count</em> lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves forward by 0 - <em>count</em> lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of lines to move backward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a id="ae928b83540d864698b26264d44f7d4a8" name="ae928b83540d864698b26264d44f7d4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae928b83540d864698b26264d44f7d4a8">&#9670;&#160;</a></span>backward_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_search </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gtkmmEnums.html#ga45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>match_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classGtk_1_1TextIter.html#a4a40c08f1ebe2fdbfba0a438b07dd916">backward_search()</a>, but searches to the start. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Search string. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitmask of flags affecting the search. </td></tr>
    <tr><td class="paramname">match_start</td><td>Return location for start of match, or <code>0</code>. </td></tr>
    <tr><td class="paramname">match_end</td><td>Return location for end of match, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a match was found. </dd></dl>

</div>
</div>
<a id="a4a40c08f1ebe2fdbfba0a438b07dd916" name="a4a40c08f1ebe2fdbfba0a438b07dd916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a40c08f1ebe2fdbfba0a438b07dd916">&#9670;&#160;</a></span>backward_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_search </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gtkmmEnums.html#ga45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>match_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classGtk_1_1TextIter.html#a3be0a5bcccde0a25b5814e90c6b6bd71">forward_search()</a>, but moves backward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Search string. </td></tr>
    <tr><td class="paramname">flags</td><td>Bitmask of flags affecting the search. </td></tr>
    <tr><td class="paramname">match_start</td><td>Return location for start of match. </td></tr>
    <tr><td class="paramname">match_end</td><td>Return location for end of match. </td></tr>
    <tr><td class="paramname">limit</td><td>Location of last possible <em>match_start</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a match was found. </dd></dl>

</div>
</div>
<a id="a7e0855474df38a9084db2cec9171140a" name="a7e0855474df38a9084db2cec9171140a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0855474df38a9084db2cec9171140a">&#9670;&#160;</a></span>backward_sentence_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_sentence_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves backward to the previous sentence start; if <em>iter</em> is already at the start of a sentence, moves backward to the next one. Sentence boundaries are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango text boundary algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="a86618c5b23bebc739057651aded7751a" name="a86618c5b23bebc739057651aded7751a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86618c5b23bebc739057651aded7751a">&#9670;&#160;</a></span>backward_sentence_starts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_sentence_starts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <a class="el" href="classGtk_1_1TextIter.html#a7e0855474df38a9084db2cec9171140a">backward_sentence_start()</a> up to <em>count</em> times, or until it returns <code>false</code>. If <em>count</em> is negative, moves forward instead of backward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of sentences to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="ad17e2abaf014a0796ad7c668ca378d58" name="ad17e2abaf014a0796ad7c668ca378d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17e2abaf014a0796ad7c668ca378d58">&#9670;&#160;</a></span>backward_to_tag_toggle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_to_tag_toggle </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves backward to the next toggle (on or off) of the <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>0</code>. If no matching tag toggles are found, returns <code>false</code>, otherwise <code>true</code>. Does not return toggles located at <em>iter</em>, only toggles before <em>iter</em>. Sets <em>iter</em> to the location of the toggle, or the start of the buffer if no toggle is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we found a tag toggle before <em>iter</em>. </dd></dl>

</div>
</div>
<a id="a3ff24ef7f2c58692eb320365cd0d8001" name="a3ff24ef7f2c58692eb320365cd0d8001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff24ef7f2c58692eb320365cd0d8001">&#9670;&#160;</a></span>backward_visible_cursor_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_cursor_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>iter</em> forward to the previous visible cursor position. See <a class="el" href="classGtk_1_1TextIter.html#ac8a84e76bdbf9c60b214c964a47907d0">backward_cursor_position()</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a id="a455e4560fbd1fa19a6f8caea4348255f" name="a455e4560fbd1fa19a6f8caea4348255f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455e4560fbd1fa19a6f8caea4348255f">&#9670;&#160;</a></span>backward_visible_cursor_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_cursor_positions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves up to <em>count</em> visible cursor positions. See <a class="el" href="classGtk_1_1TextIter.html#ac8a84e76bdbf9c60b214c964a47907d0">backward_cursor_position()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of positions to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a id="a2d52ce38268847ed46cefca328b478cd" name="a2d52ce38268847ed46cefca328b478cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d52ce38268847ed46cefca328b478cd">&#9670;&#160;</a></span>backward_visible_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>iter</em> to the start of the previous visible line. Returns <code>true</code> if <em>iter</em> could be moved; i.e. if <em>iter</em> was at character offset 0, this function returns <code>false</code>. Therefore if <em>iter</em> was already on line 0, but not at the start of the line, <em>iter</em> is snapped to the start of the line and the function returns <code>true</code>. (<a class="el" href="classNote.html">Note</a> that this implies that in a loop calling this function, the line number may not change on every iteration, if your first iteration is on line 0.)</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved. </dd></dl>

</div>
</div>
<a id="a435bac2e52fac10cbd4c5175fcc6893c" name="a435bac2e52fac10cbd4c5175fcc6893c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435bac2e52fac10cbd4c5175fcc6893c">&#9670;&#160;</a></span>backward_visible_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_lines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>count</em> visible lines backward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves forward by 0 - <em>count</em> lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of lines to move backward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a id="a9e1afad7efe043ebf9f8c8a0aa6b8034" name="a9e1afad7efe043ebf9f8c8a0aa6b8034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1afad7efe043ebf9f8c8a0aa6b8034">&#9670;&#160;</a></span>backward_visible_word_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_word_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves backward to the previous visible word start. (If <em>iter</em> is currently on a word start, moves backward to the next one after that.) Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="a432ef8da68c876335cb020e24b5880d4" name="a432ef8da68c876335cb020e24b5880d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432ef8da68c876335cb020e24b5880d4">&#9670;&#160;</a></span>backward_visible_word_starts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_visible_word_starts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <a class="el" href="classGtk_1_1TextIter.html#a9e1afad7efe043ebf9f8c8a0aa6b8034">backward_visible_word_start()</a> up to <em>count</em> times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of times to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="a8f8136c917007d6a4a7c7969221410d2" name="a8f8136c917007d6a4a7c7969221410d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8136c917007d6a4a7c7969221410d2">&#9670;&#160;</a></span>backward_word_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_word_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves backward to the previous word start. (If <em>iter</em> is currently on a word start, moves backward to the next one after that.) Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="a14f5b1eeec69bdd6443b75a659407dd8" name="a14f5b1eeec69bdd6443b75a659407dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f5b1eeec69bdd6443b75a659407dd8">&#9670;&#160;</a></span>backward_word_starts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::backward_word_starts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <a class="el" href="classGtk_1_1TextIter.html#a8f8136c917007d6a4a7c7969221410d2">backward_word_start()</a> up to <em>count</em> times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of times to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="a5741217aa0478fc2abea8f9429722839" name="a5741217aa0478fc2abea8f9429722839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5741217aa0478fc2abea8f9429722839">&#9670;&#160;</a></span>begins_tag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::begins_tag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f07a9e1606add1754568c80e4ac1a58" name="a3f07a9e1606add1754568c80e4ac1a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f07a9e1606add1754568c80e4ac1a58">&#9670;&#160;</a></span>begins_tag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::begins_tag </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <em>tag</em> is toggled on at exactly this point. If <em>tag</em> is <code>0</code>, returns <code>true</code> if any tag is toggled on at this point. <a class="el" href="classNote.html">Note</a> that the <a class="el" href="classGtk_1_1TextIter.html#a3f07a9e1606add1754568c80e4ac1a58">begins_tag()</a> returns <code>true</code> if <em>iter</em> is the <em>start</em> of the tagged range; <a class="el" href="classGtk_1_1TextIter.html#a7014ff418003017a0b1d5a9f18c35599">has_tag()</a> tells you whether an iterator is <em>within</em> a tagged range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is the start of a range tagged with <em>tag</em>. </dd></dl>

</div>
</div>
<a id="a06a4db2657260da865de31cddd3a76da" name="a06a4db2657260da865de31cddd3a76da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a4db2657260da865de31cddd3a76da">&#9670;&#160;</a></span>can_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::can_insert </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>default_editability</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Considering the default editability of the buffer, and tags that affect editability, determines whether text inserted at <em>iter</em> would be editable. If text inserted at <em>iter</em> would be editable then the user should be allowed to insert text at <em>iter</em>. <a class="el" href="classGtk_1_1TextBuffer.html#ab0ee4a3d4ebb327628ee945758101620">Gtk::TextBuffer::insert_interactive()</a> uses this function to decide whether insertions are allowed at a given position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_editability</td><td><code>true</code> if text is editable by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether text inserted at <em>iter</em> would be editable. </dd></dl>

</div>
</div>
<a id="aef515c327715f80fd35355c075d8f120" name="aef515c327715f80fd35355c075d8f120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef515c327715f80fd35355c075d8f120">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A qsort()-style function that returns negative if <em>lhs</em> is less than <em>rhs</em>, positive if <em>lhs</em> is greater than <em>rhs</em>, and 0 if they're equal. Ordering is in character offset order, i.e. the first character in the buffer is less than the second character in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Another <a class="el" href="classGtk_1_1TextIter.html">Gtk::TextIter</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <em>lhs</em> is less than <em>rhs</em>, 1 if <em>lhs</em> is greater, 0 if they are equal. </dd></dl>

</div>
</div>
<a id="acabdbb0fe11b79e0bb3e6c95eb7e60ac" name="acabdbb0fe11b79e0bb3e6c95eb7e60ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabdbb0fe11b79e0bb3e6c95eb7e60ac">&#9670;&#160;</a></span>editable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::editable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>default_setting</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the character at <em>iter</em> is within an editable region of text. Non-editable text is "locked" and can't be changed by the user via <a class="el" href="classGtk_1_1TextView.html">Gtk::TextView</a>. This function is simply a convenience wrapper around <a class="el" href="classGtk_1_1TextIter.html#aa55f93e8895ea4257ad9bfe38c1fd530">get_attributes()</a>. If no tags applied to this text affect editability, <em>default_setting</em> will be returned.</p>
<p>You don't want to use this function to decide whether text can be inserted at <em>iter</em>, because for insertion you don't want to know whether the char at <em>iter</em> is inside an editable range, you want to know whether a new character inserted at <em>iter</em> would be inside an editable range. Use <a class="el" href="classGtk_1_1TextIter.html#a06a4db2657260da865de31cddd3a76da">can_insert()</a> to handle this case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_setting</td><td><code>true</code> if text is editable by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is inside an editable range. </dd></dl>

</div>
</div>
<a id="aa858e906ce5d54740b6034c9e916fa8e" name="aa858e906ce5d54740b6034c9e916fa8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa858e906ce5d54740b6034c9e916fa8e">&#9670;&#160;</a></span>ends_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::ends_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <em>iter</em> points to the start of the paragraph delimiter characters for a line (delimiters will be either a newline, a carriage return, a carriage return followed by a newline, or a Unicode paragraph separator character). <a class="el" href="classNote.html">Note</a> that an iterator pointing to the \n of a \r\n pair will not be counted as the end of a line, the line ends before the \r. The end iterator is considered to be at the end of a line, even though there are no paragraph delimiter chars there.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is at the end of a line. </dd></dl>

</div>
</div>
<a id="a771764060ebee507f9f846404ef13d31" name="a771764060ebee507f9f846404ef13d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771764060ebee507f9f846404ef13d31">&#9670;&#160;</a></span>ends_sentence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::ends_sentence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether <em>iter</em> ends a sentence. Sentence boundaries are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango text boundary algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is at the end of a sentence. </dd></dl>

</div>
</div>
<a id="a0ea455127c3147b71ae88665aab53a4f" name="a0ea455127c3147b71ae88665aab53a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea455127c3147b71ae88665aab53a4f">&#9670;&#160;</a></span>ends_tag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::ends_tag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35645f29b1476ce8a7b899d343663e41" name="a35645f29b1476ce8a7b899d343663e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35645f29b1476ce8a7b899d343663e41">&#9670;&#160;</a></span>ends_tag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::ends_tag </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <em>tag</em> is toggled off at exactly this point. If <em>tag</em> is <code>0</code>, returns <code>true</code> if any tag is toggled off at this point. <a class="el" href="classNote.html">Note</a> that the <a class="el" href="classGtk_1_1TextIter.html#a35645f29b1476ce8a7b899d343663e41">ends_tag()</a> returns <code>true</code> if <em>iter</em> is the <em>end</em> of the tagged range; <a class="el" href="classGtk_1_1TextIter.html#a7014ff418003017a0b1d5a9f18c35599">has_tag()</a> tells you whether an iterator is <em>within</em> a tagged range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is the end of a range tagged with <em>tag</em>. </dd></dl>

</div>
</div>
<a id="a34d680c52f36b84500340a3c5d848b9a" name="a34d680c52f36b84500340a3c5d848b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d680c52f36b84500340a3c5d848b9a">&#9670;&#160;</a></span>ends_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::ends_word </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether <em>iter</em> ends a natural-language word. Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is at the end of a word. </dd></dl>

</div>
</div>
<a id="a46acea844c69273d92c63d910eca21c9" name="a46acea844c69273d92c63d910eca21c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46acea844c69273d92c63d910eca21c9">&#9670;&#160;</a></span>forward_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_char </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>iter</em> forward by one character offset. <a class="el" href="classNote.html">Note</a> that images embedded in the buffer occupy 1 character slot, so <a class="el" href="classGtk_1_1TextIter.html#a46acea844c69273d92c63d910eca21c9">forward_char()</a> may actually move onto an image instead of a character, if you have images in your buffer. If <em>iter</em> is the end iterator or one character before it, <em>iter</em> will now point at the end iterator, and <a class="el" href="classGtk_1_1TextIter.html#a46acea844c69273d92c63d910eca21c9">forward_char()</a> returns <code>false</code> for convenience when writing loops.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a id="aadbab55d587698d0f51776faa0cc2a43" name="aadbab55d587698d0f51776faa0cc2a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbab55d587698d0f51776faa0cc2a43">&#9670;&#160;</a></span>forward_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_chars </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>count</em> characters if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the new position of <em>iter</em> is different from its original position, and dereferenceable (the last iterator in the buffer is not dereferenceable). If <em>count</em> is 0, the function does nothing and returns <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of characters to move, may be negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a id="ac43e1833c36390271f139096f2246684" name="ac43e1833c36390271f139096f2246684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43e1833c36390271f139096f2246684">&#9670;&#160;</a></span>forward_cursor_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_cursor_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>iter</em> forward by a single cursor position. Cursor positions are (unsurprisingly) positions where the cursor can appear. Perhaps surprisingly, there may not be a cursor position between all characters. The most common example for European languages would be a carriage return/newline sequence. For some Unicode characters, the equivalent of say the letter "a" with an accent mark will be represented as two characters, first the letter then a "combining
mark" that causes the accent to be rendered; so the cursor can't go between those two characters. See also the Pango::LogAttr structure and pango_break() function.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a id="a8b20683d7513dfb331bb0a1aeffa63c5" name="a8b20683d7513dfb331bb0a1aeffa63c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b20683d7513dfb331bb0a1aeffa63c5">&#9670;&#160;</a></span>forward_cursor_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_cursor_positions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves up to <em>count</em> cursor positions. See <a class="el" href="classGtk_1_1TextIter.html#ac43e1833c36390271f139096f2246684">forward_cursor_position()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of positions to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a id="a1e72a44551eb03237a0c9919cebdf371" name="a1e72a44551eb03237a0c9919cebdf371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e72a44551eb03237a0c9919cebdf371">&#9670;&#160;</a></span>forward_find_char() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_find_char </td>
          <td>(</td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12d514e9a2cb99e547426dce3653949c" name="a12d514e9a2cb99e547426dce3653949c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d514e9a2cb99e547426dce3653949c">&#9670;&#160;</a></span>forward_find_char() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_find_char </td>
          <td>(</td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca8832f0168bbcf8651cff1eb632f13f" name="aca8832f0168bbcf8651cff1eb632f13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8832f0168bbcf8651cff1eb632f13f">&#9670;&#160;</a></span>forward_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>iter</em> to the start of the next line. If the iter is already on the last line of the buffer, moves the iter to the end of the current line. If after the operation, the iter is at the end of the buffer and not dereferencable, returns <code>false</code>. Otherwise, returns <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> can be dereferenced. </dd></dl>

</div>
</div>
<a id="adb054a9ee7862010ad5564571bda2552" name="adb054a9ee7862010ad5564571bda2552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb054a9ee7862010ad5564571bda2552">&#9670;&#160;</a></span>forward_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_lines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>count</em> lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves backward by 0 - <em>count</em> lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of lines to move forward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a id="aa32b69adde44a214857d8e8a5bb7ed4a" name="aa32b69adde44a214857d8e8a5bb7ed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32b69adde44a214857d8e8a5bb7ed4a">&#9670;&#160;</a></span>forward_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_search </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gtkmmEnums.html#ga45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>match_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classGtk_1_1TextIter.html#a3be0a5bcccde0a25b5814e90c6b6bd71">forward_search()</a>, but searchs to the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A search string. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting how the search is done. </td></tr>
    <tr><td class="paramname">match_start</td><td>Return location for start of match, or <code>0</code>. </td></tr>
    <tr><td class="paramname">match_end</td><td>Return location for end of match, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a match was found. </dd></dl>

</div>
</div>
<a id="a3be0a5bcccde0a25b5814e90c6b6bd71" name="a3be0a5bcccde0a25b5814e90c6b6bd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be0a5bcccde0a25b5814e90c6b6bd71">&#9670;&#160;</a></span>forward_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_search </td>
          <td>(</td>
          <td class="paramtype">const Glib::ustring &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gtkmmEnums.html#ga45bb48ef86a7da2535de94066029bc29">TextSearchFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>match_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>match_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches forward for <em>str</em>. Any match is returned by setting <em>match_start</em> to the first character of the match and <em>match_end</em> to the first character after the match. The search will not continue past <em>limit</em>. <a class="el" href="classNote.html">Note</a> that a search is a linear or O(n) operation, so you may wish to use <em>limit</em> to avoid locking up your UI on large buffers.</p>
<p>If the <a class="el" href="group__gtkmmEnums.html#gga45bb48ef86a7da2535de94066029bc29a0b28cb0bb916b26583fc45f408fe3862">Gtk::TEXT_SEARCH_VISIBLE_ONLY</a> flag is present, the match may have invisible text interspersed in <em>str</em>. i.e. <em>str</em> will be a possibly-noncontiguous subsequence of the matched range. similarly, if you specify <a class="el" href="group__gtkmmEnums.html#gga45bb48ef86a7da2535de94066029bc29a9e7c657edf1a930f28a43fb22314d063">Gtk::TEXT_SEARCH_TEXT_ONLY</a>, the match may have pixbufs or child widgets mixed inside the matched range. If these flags are not given, the match must be exact; the special 0xFFFC character in <em>str</em> will match embedded pixbufs or child widgets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A search string. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting how the search is done. </td></tr>
    <tr><td class="paramname">match_start</td><td>Return location for start of match. </td></tr>
    <tr><td class="paramname">match_end</td><td>Return location for end of match. </td></tr>
    <tr><td class="paramname">limit</td><td>Bound for the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a match was found. </dd></dl>

</div>
</div>
<a id="a2d1c3dc0fa3c7545e6a09aa082e4032e" name="a2d1c3dc0fa3c7545e6a09aa082e4032e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1c3dc0fa3c7545e6a09aa082e4032e">&#9670;&#160;</a></span>forward_sentence_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_sentence_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves forward to the next sentence end. (If <em>iter</em> is at the end of a sentence, moves to the next end of sentence.) Sentence boundaries are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango text boundary algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="a6aef31e21147f939af5f34ef930f16bf" name="a6aef31e21147f939af5f34ef930f16bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aef31e21147f939af5f34ef930f16bf">&#9670;&#160;</a></span>forward_sentence_ends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_sentence_ends </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <a class="el" href="classGtk_1_1TextIter.html#a2d1c3dc0fa3c7545e6a09aa082e4032e">forward_sentence_end()</a> <em>count</em> times (or until <a class="el" href="classGtk_1_1TextIter.html#a2d1c3dc0fa3c7545e6a09aa082e4032e">forward_sentence_end()</a> returns <code>false</code>). If <em>count</em> is negative, moves backward instead of forward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of sentences to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="a70abfc30933f0e8dec3f014128443dc4" name="a70abfc30933f0e8dec3f014128443dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70abfc30933f0e8dec3f014128443dc4">&#9670;&#160;</a></span>forward_to_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::forward_to_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>iter</em> forward to the "end iterator," which points one past the last valid character in the buffer. <a class="el" href="classGtk_1_1TextIter.html#acf4a9e85bc094f7ed798b7b3491ddd92">get_char()</a> called on the end iterator returns 0, which is convenient for writing loops. </p>

</div>
</div>
<a id="a31f8195cab1810e35b88122d2ebd7b90" name="a31f8195cab1810e35b88122d2ebd7b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f8195cab1810e35b88122d2ebd7b90">&#9670;&#160;</a></span>forward_to_line_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_to_line_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the iterator to point to the paragraph delimiter characters, which will be either a newline, a carriage return, a carriage return/newline in sequence, or the Unicode paragraph separator character. If the iterator is already at the paragraph delimiter characters, moves to the paragraph delimiter characters for the next line. If <em>iter</em> is on the last line in the buffer, which does not end in paragraph delimiters, moves to the end iterator (end of the last line), and returns <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new location is not the end iterator. </dd></dl>

</div>
</div>
<a id="a89b4fc66df6e0b9b8046c2f70b261629" name="a89b4fc66df6e0b9b8046c2f70b261629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b4fc66df6e0b9b8046c2f70b261629">&#9670;&#160;</a></span>forward_to_tag_toggle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_to_tag_toggle </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves forward to the next toggle (on or off) of the <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a> <em>tag</em>, or to the next toggle of any tag if <em>tag</em> is <code>0</code>. If no matching tag toggles are found, returns <code>false</code>, otherwise <code>true</code>. Does not return toggles located at <em>iter</em>, only toggles after <em>iter</em>. Sets <em>iter</em> to the location of the toggle, or to the end of the buffer if no toggle is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we found a tag toggle after <em>iter</em>. </dd></dl>

</div>
</div>
<a id="a647f1e0b30b3ad9470d67f8d42108d6a" name="a647f1e0b30b3ad9470d67f8d42108d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647f1e0b30b3ad9470d67f8d42108d6a">&#9670;&#160;</a></span>forward_visible_cursor_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_cursor_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>iter</em> forward to the next visible cursor position. See <a class="el" href="classGtk_1_1TextIter.html#ac43e1833c36390271f139096f2246684">forward_cursor_position()</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a id="a770ab9cd1f2dd86d586567cb19f8d9a4" name="a770ab9cd1f2dd86d586567cb19f8d9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770ab9cd1f2dd86d586567cb19f8d9a4">&#9670;&#160;</a></span>forward_visible_cursor_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_cursor_positions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves up to <em>count</em> visible cursor positions. See <a class="el" href="classGtk_1_1TextIter.html#ac43e1833c36390271f139096f2246684">forward_cursor_position()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of positions to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we moved and the new position is dereferenceable. </dd></dl>

</div>
</div>
<a id="a506be5cb9d7dd29522b71cddd520bda3" name="a506be5cb9d7dd29522b71cddd520bda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506be5cb9d7dd29522b71cddd520bda3">&#9670;&#160;</a></span>forward_visible_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>iter</em> to the start of the next visible line. Returns <code>true</code> if there was a next line to move to, and <code>false</code> if <em>iter</em> was simply moved to the end of the buffer and is now not dereferenceable, or if <em>iter</em> was already at the end of the buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> can be dereferenced. </dd></dl>

</div>
</div>
<a id="a55a295c7dead80d24470f33a67a6dd74" name="a55a295c7dead80d24470f33a67a6dd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a295c7dead80d24470f33a67a6dd74">&#9670;&#160;</a></span>forward_visible_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_line </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>count</em> visible lines forward, if possible (if <em>count</em> would move past the start or end of the buffer, moves to the start or end of the buffer). The return value indicates whether the iterator moved onto a dereferenceable position; if the iterator didn't move, or moved onto the end iterator, then <code>false</code> is returned. If <em>count</em> is 0, the function does nothing and returns <code>false</code>. If <em>count</em> is negative, moves backward by 0 - <em>count</em> lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of lines to move forward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> moved and is dereferenceable. </dd></dl>

</div>
</div>
<a id="ac79bd3e6c8cd7ccdc45b8ed8064986e8" name="ac79bd3e6c8cd7ccdc45b8ed8064986e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79bd3e6c8cd7ccdc45b8ed8064986e8">&#9670;&#160;</a></span>forward_visible_word_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_word_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves forward to the next visible word end. (If <em>iter</em> is currently on a word end, moves forward to the next one after that.) Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="ad9a7521c3392d07d24790702433cd1ff" name="ad9a7521c3392d07d24790702433cd1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a7521c3392d07d24790702433cd1ff">&#9670;&#160;</a></span>forward_visible_word_ends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_visible_word_ends </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <a class="el" href="classGtk_1_1TextIter.html#ac79bd3e6c8cd7ccdc45b8ed8064986e8">forward_visible_word_end()</a> up to <em>count</em> times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of times to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="a05bba655ab512cf1569590d9206d797b" name="a05bba655ab512cf1569590d9206d797b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bba655ab512cf1569590d9206d797b">&#9670;&#160;</a></span>forward_word_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_word_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves forward to the next word end. (If <em>iter</em> is currently on a word end, moves forward to the next one after that.) Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="aa7d74cb53546701ec0b42266ac40e2a1" name="aa7d74cb53546701ec0b42266ac40e2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d74cb53546701ec0b42266ac40e2a1">&#9670;&#160;</a></span>forward_word_ends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::forward_word_ends </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <a class="el" href="classGtk_1_1TextIter.html#a05bba655ab512cf1569590d9206d797b">forward_word_end()</a> up to <em>count</em> times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of times to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> moved and is not the end iterator. </dd></dl>

</div>
</div>
<a id="aa55f93e8895ea4257ad9bfe38c1fd530" name="aa55f93e8895ea4257ad9bfe38c1fd530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55f93e8895ea4257ad9bfe38c1fd530">&#9670;&#160;</a></span>get_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::get_attributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextAttributes.html">TextAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f42cc6fc233b4daadab5490297f1334" name="a6f42cc6fc233b4daadab5490297f1334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f42cc6fc233b4daadab5490297f1334">&#9670;&#160;</a></span>get_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextBuffer.html">TextBuffer</a> &gt; Gtk::TextIter::get_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classGtk_1_1TextBuffer.html">Gtk::TextBuffer</a> this iterator is associated with.</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer. </dd></dl>

</div>
</div>
<a id="adc9c9c23869934ea6ea27079b7f4f77f" name="adc9c9c23869934ea6ea27079b7f4f77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9c9c23869934ea6ea27079b7f4f77f">&#9670;&#160;</a></span>get_bytes_in_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_bytes_in_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of bytes in the line containing <em>iter</em>, including the paragraph delimiters.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in the line. </dd></dl>

</div>
</div>
<a id="acf4a9e85bc094f7ed798b7b3491ddd92" name="acf4a9e85bc094f7ed798b7b3491ddd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4a9e85bc094f7ed798b7b3491ddd92">&#9670;&#160;</a></span>get_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gunichar Gtk::TextIter::get_char </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Unicode character at this iterator. (Equivalent to operator* on a C++ iterator.) If the element at this iterator is a non-character element, such as an image embedded in the buffer, the Unicode "unknown" character 0xFFFC is returned. If invoked on the end iterator, zero is returned; zero is not a valid Unicode character. So you can write a loop which ends when <a class="el" href="classGtk_1_1TextIter.html#acf4a9e85bc094f7ed798b7b3491ddd92">get_char()</a> returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>A Unicode character, or 0 if <em>iter</em> is not dereferenceable. </dd></dl>

</div>
</div>
<a id="a7d2a73293b9fc58fcb2ccb7f6b819012" name="a7d2a73293b9fc58fcb2ccb7f6b819012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2a73293b9fc58fcb2ccb7f6b819012">&#9670;&#160;</a></span>get_chars_in_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_chars_in_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of characters in the line containing <em>iter</em>, including the paragraph delimiters.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of characters in the line. </dd></dl>

</div>
</div>
<a id="ad7be1fa66eafad2e64b313c57a9cb886" name="ad7be1fa66eafad2e64b313c57a9cb886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7be1fa66eafad2e64b313c57a9cb886">&#9670;&#160;</a></span>get_child_anchor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextChildAnchor.html">TextChildAnchor</a> &gt; Gtk::TextIter::get_child_anchor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the location at <em>iter</em> contains a child anchor, the anchor is returned (with no new reference count added). Otherwise, <code>0</code> is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The anchor at <em>iter</em>. </dd></dl>

</div>
</div>
<a id="a8e020cb7163d423a8ef1621d968b14d2" name="a8e020cb7163d423a8ef1621d968b14d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e020cb7163d423a8ef1621d968b14d2">&#9670;&#160;</a></span>get_child_anchor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextChildAnchor.html">TextChildAnchor</a> &gt; Gtk::TextIter::get_child_anchor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the location at <em>iter</em> contains a child anchor, the anchor is returned (with no new reference count added). Otherwise, <code>0</code> is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The anchor at <em>iter</em>. </dd></dl>

</div>
</div>
<a id="a5a90a51fc27c4f9a46380e02b9cb3a6c" name="a5a90a51fc27c4f9a46380e02b9cb3a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a90a51fc27c4f9a46380e02b9cb3a6c">&#9670;&#160;</a></span>get_language()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Pango::Language Gtk::TextIter::get_language </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience wrapper around <a class="el" href="classGtk_1_1TextIter.html#aa55f93e8895ea4257ad9bfe38c1fd530">get_attributes()</a>, which returns the language in effect at <em>iter</em>. If no tags affecting language apply to <em>iter</em>, the return value is identical to that of <a class="el" href="gtkmain_8h.html#a0870053677ddfcfd3b6bc51c056e1a0d">gtk_get_default_language()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Language in effect at <em>iter</em>. </dd></dl>

</div>
</div>
<a id="a3cb1fe241ed39c3a7bc3f94d6b63da53" name="a3cb1fe241ed39c3a7bc3f94d6b63da53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb1fe241ed39c3a7bc3f94d6b63da53">&#9670;&#160;</a></span>get_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the line number containing the iterator. Lines in a <a class="el" href="classGtk_1_1TextBuffer.html">Gtk::TextBuffer</a> are numbered beginning with 0 for the first line in the buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>A line number. </dd></dl>

</div>
</div>
<a id="a8951d3815c0b9634e278cce421b97ad9" name="a8951d3815c0b9634e278cce421b97ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8951d3815c0b9634e278cce421b97ad9">&#9670;&#160;</a></span>get_line_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_line_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the byte index of the iterator, counting from the start of a newline-terminated line. Remember that <a class="el" href="classGtk_1_1TextBuffer.html">Gtk::TextBuffer</a> encodes text in UTF-8, and that characters can require a variable number of bytes to represent.</p>
<dl class="section return"><dt>Returns</dt><dd>Distance from start of line, in bytes. </dd></dl>

</div>
</div>
<a id="ad2c6ca9348bb89f4e1f614954118f41b" name="ad2c6ca9348bb89f4e1f614954118f41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c6ca9348bb89f4e1f614954118f41b">&#9670;&#160;</a></span>get_line_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_line_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the character offset of the iterator, counting from the start of a newline-terminated line. The first character on the line has offset 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Offset from start of line. </dd></dl>

</div>
</div>
<a id="aafa1d35bc0fe07dfd4c46c1a1935561f" name="aafa1d35bc0fe07dfd4c46c1a1935561f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa1d35bc0fe07dfd4c46c1a1935561f">&#9670;&#160;</a></span>get_marks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt; Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextMark.html">TextMark</a> &gt; &gt; Gtk::TextIter::get_marks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of all <a class="el" href="classGtk_1_1TextMark.html">Gtk::TextMark</a> at this location. Because marks are not iterable (they don't take up any "space" in the buffer, they are just marks in between iterable locations), multiple marks can exist in the same place. The returned list is not in any meaningful order.</p>
<dl class="section return"><dt>Returns</dt><dd>List of <a class="el" href="classGtk_1_1TextMark.html">Gtk::TextMark</a>. </dd></dl>

</div>
</div>
<a id="af3c268ce5a1c7037a2aced64592ff86c" name="af3c268ce5a1c7037a2aced64592ff86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c268ce5a1c7037a2aced64592ff86c">&#9670;&#160;</a></span>get_marks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt; Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextMark.html">TextMark</a> &gt; &gt; Gtk::TextIter::get_marks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of all <a class="el" href="classGtk_1_1TextMark.html">Gtk::TextMark</a> at this location. Because marks are not iterable (they don't take up any "space" in the buffer, they are just marks in between iterable locations), multiple marks can exist in the same place. The returned list is not in any meaningful order.</p>
<dl class="section return"><dt>Returns</dt><dd>List of <a class="el" href="classGtk_1_1TextMark.html">Gtk::TextMark</a>. </dd></dl>

</div>
</div>
<a id="a1fdd5eb44a819d9ef4bd8d1f71647a2c" name="a1fdd5eb44a819d9ef4bd8d1f71647a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdd5eb44a819d9ef4bd8d1f71647a2c">&#9670;&#160;</a></span>get_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the character offset of an iterator. Each character in a <a class="el" href="classGtk_1_1TextBuffer.html">Gtk::TextBuffer</a> has an offset, starting with 0 for the first character in the buffer. Use <a class="el" href="classGtk_1_1TextBuffer.html#ae92edc6a06a9a5fae2ee99f762bb59ff">Gtk::TextBuffer::get_iter_at_offset()</a> to convert an offset back into an iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>A character offset. </dd></dl>

</div>
</div>
<a id="a232d63bb9d0691fdaa838652e8307580" name="a232d63bb9d0691fdaa838652e8307580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232d63bb9d0691fdaa838652e8307580">&#9670;&#160;</a></span>get_pixbuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::RefPtr&lt; <a class="el" href="classGdk_1_1Pixbuf.html">Gdk::Pixbuf</a> &gt; Gtk::TextIter::get_pixbuf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the element at <em>iter</em> is a pixbuf, the pixbuf is returned (with no new reference count added). Otherwise, <code>0</code> is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The pixbuf at <em>iter</em>. </dd></dl>

</div>
</div>
<a id="a2de7abe2170a48356a6da445114bc458" name="a2de7abe2170a48356a6da445114bc458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de7abe2170a48356a6da445114bc458">&#9670;&#160;</a></span>get_slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextIter::get_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the text in the given range. A "slice" is an array of characters encoded in UTF-8 format, including the Unicode "unknown" character 0xFFFC for iterable non-character elements in the buffer, such as images. Because images are encoded in the slice, byte and character offsets in the returned array will correspond to byte offsets in the text buffer. <a class="el" href="classNote.html">Note</a> that 0xFFFC can occur in normal text as well, so it is not a reliable indicator that a pixbuf or widget is in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end</td><td><a class="el" href="classIterator.html">Iterator</a> at end of a range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Slice of text from the buffer. </dd></dl>

</div>
</div>
<a id="a7ba16544194fa61ada320c6c580d15d8" name="a7ba16544194fa61ada320c6c580d15d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba16544194fa61ada320c6c580d15d8">&#9670;&#160;</a></span>get_tags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt; Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &gt; Gtk::TextIter::get_tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of tags that apply to <em>iter</em>, in ascending order of priority (highest-priority tags are last).</p>
<dl class="section return"><dt>Returns</dt><dd>List of <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a>. </dd></dl>

</div>
</div>
<a id="afb78901b3e0dbee26c2fae2c98ec0f6e" name="afb78901b3e0dbee26c2fae2c98ec0f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb78901b3e0dbee26c2fae2c98ec0f6e">&#9670;&#160;</a></span>get_tags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt; Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &gt; Gtk::TextIter::get_tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of tags that apply to <em>iter</em>, in ascending order of priority (highest-priority tags are last).</p>
<dl class="section return"><dt>Returns</dt><dd>List of <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a>. </dd></dl>

</div>
</div>
<a id="ae8390096614364d86f576244b31c108c" name="ae8390096614364d86f576244b31c108c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8390096614364d86f576244b31c108c">&#9670;&#160;</a></span>get_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextIter::get_text </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <em>text</em> in the given range. If the range contains non-text elements such as images, the character and byte offsets in the returned string will not correspond to character and byte offsets in the buffer. If you want offsets to correspond, see <a class="el" href="classGtk_1_1TextIter.html#a2de7abe2170a48356a6da445114bc458">get_slice()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end</td><td><a class="el" href="classIterator.html">Iterator</a> at end of a range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of characters from the buffer. </dd></dl>

</div>
</div>
<a id="af041478bda20f0e9e3ce655da7205c7c" name="af041478bda20f0e9e3ce655da7205c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af041478bda20f0e9e3ce655da7205c7c">&#9670;&#160;</a></span>get_toggled_tags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt; Glib::RefPtr&lt; <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &gt; Gtk::TextIter::get_toggled_tags </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toggled_on</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a> that are toggled on or off at this point. (If <em>toggled_on</em> is <code>true</code>, the list contains tags that are toggled on.) If a tag is toggled on at <em>iter</em>, then some non-empty range of characters following <em>iter</em> has that tag applied to it. If a tag is toggled off, then some non-empty range following <em>iter</em> does <em>not</em> have the tag applied to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toggled_on</td><td><code>true</code> to get toggled-on tags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tags toggled at this point. </dd></dl>

</div>
</div>
<a id="a324910dee0a64465bf56328962c5c375" name="a324910dee0a64465bf56328962c5c375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324910dee0a64465bf56328962c5c375">&#9670;&#160;</a></span>get_toggled_tags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::SListHandle&lt; Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &gt; Gtk::TextIter::get_toggled_tags </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toggled_on</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a> that are toggled on or off at this point. (If <em>toggled_on</em> is <code>true</code>, the list contains tags that are toggled on.) If a tag is toggled on at <em>iter</em>, then some non-empty range of characters following <em>iter</em> has that tag applied to it. If a tag is toggled off, then some non-empty range following <em>iter</em> does <em>not</em> have the tag applied to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toggled_on</td><td><code>true</code> to get toggled-on tags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tags toggled at this point. </dd></dl>

</div>
</div>
<a id="ab57cf6632e541c259536162fb9047f66" name="ab57cf6632e541c259536162fb9047f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57cf6632e541c259536162fb9047f66">&#9670;&#160;</a></span>get_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static GType Gtk::TextIter::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the GType for this class, for use with the underlying GObject type system. </p>

</div>
</div>
<a id="a2b82b9e7c687a662aa46c1a8dd987513" name="a2b82b9e7c687a662aa46c1a8dd987513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b82b9e7c687a662aa46c1a8dd987513">&#9670;&#160;</a></span>get_visible_line_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_visible_line_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of bytes from the start of the line to the given <em>iter</em>, not counting bytes that are invisible due to tags with the "invisible" flag toggled on.</p>
<dl class="section return"><dt>Returns</dt><dd>Byte index of <em>iter</em> with respect to the start of the line. </dd></dl>

</div>
</div>
<a id="a27f7f08e03d31e2ec644f7d94c6c483f" name="a27f7f08e03d31e2ec644f7d94c6c483f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f7f08e03d31e2ec644f7d94c6c483f">&#9670;&#160;</a></span>get_visible_line_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TextIter::get_visible_line_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the offset in characters from the start of the line to the given <em>iter</em>, not counting characters that are invisible due to tags with the "invisible" flag toggled on.</p>
<dl class="section return"><dt>Returns</dt><dd>Offset in visible characters from the start of the line. </dd></dl>

</div>
</div>
<a id="a49baac63b7a846693f223d6238fd2748" name="a49baac63b7a846693f223d6238fd2748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49baac63b7a846693f223d6238fd2748">&#9670;&#160;</a></span>get_visible_slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextIter::get_visible_slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="classGtk_1_1TextIter.html#a2de7abe2170a48356a6da445114bc458">get_slice()</a>, but invisible text is not included. <a class="el" href="classGtk_1_1Invisible.html">Invisible</a> text is usually invisible because a <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a> with the "invisible" attribute turned on has been applied to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end</td><td><a class="el" href="classIterator.html">Iterator</a> at end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Slice of text from the buffer. </dd></dl>

</div>
</div>
<a id="a006c1df0a2b4324ccfabd1f62bb1dfc1" name="a006c1df0a2b4324ccfabd1f62bb1dfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006c1df0a2b4324ccfabd1f62bb1dfc1">&#9670;&#160;</a></span>get_visible_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::ustring Gtk::TextIter::get_visible_text </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="classGtk_1_1TextIter.html#ae8390096614364d86f576244b31c108c">get_text()</a>, but invisible text is not included. <a class="el" href="classGtk_1_1Invisible.html">Invisible</a> text is usually invisible because a <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a> with the "invisible" attribute turned on has been applied to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end</td><td><a class="el" href="classIterator.html">Iterator</a> at end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing visible text in the range. </dd></dl>

</div>
</div>
<a id="aeeb1b33f67670182e42c41f6f257693b" name="aeeb1b33f67670182e42c41f6f257693b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb1b33f67670182e42c41f6f257693b">&#9670;&#160;</a></span>gobj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a> * Gtk::TextIter::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. </p>

<p class="definition">Definition at line <a class="el" href="textiter_8h_source.html#l00146">146</a> of file <a class="el" href="textiter_8h_source.html">textiter.h</a>.</p>

</div>
</div>
<a id="a3f7dc42d4091db4051e625e5c4669bff" name="a3f7dc42d4091db4051e625e5c4669bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7dc42d4091db4051e625e5c4669bff">&#9670;&#160;</a></span>gobj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a> * Gtk::TextIter::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. </p>

<p class="definition">Definition at line <a class="el" href="textiter_8h_source.html#l00149">149</a> of file <a class="el" href="textiter_8h_source.html">textiter.h</a>.</p>

</div>
</div>
<a id="a802c12f54bd8e1aaaa7fad5e77ed79d5" name="a802c12f54bd8e1aaaa7fad5e77ed79d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802c12f54bd8e1aaaa7fad5e77ed79d5">&#9670;&#160;</a></span>has_tag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::has_tag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7014ff418003017a0b1d5a9f18c35599" name="a7014ff418003017a0b1d5a9f18c35599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7014ff418003017a0b1d5a9f18c35599">&#9670;&#160;</a></span>has_tag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::has_tag </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <em>iter</em> is within a range tagged with <em>tag</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is tagged with <em>tag</em>. </dd></dl>

</div>
</div>
<a id="aca810ca092905f0cc728f028be5a2f02" name="aca810ca092905f0cc728f028be5a2f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca810ca092905f0cc728f028be5a2f02">&#9670;&#160;</a></span>in_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::in_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether <em>iter</em> falls in the range [ <em>start</em>, <em>end</em>). <em>start</em> and <em>end</em> must be in ascending order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of range. </td></tr>
    <tr><td class="paramname">end</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is in the range. </dd></dl>

</div>
</div>
<a id="a6ece7b7eb8f963efef648ed23f6c99fc" name="a6ece7b7eb8f963efef648ed23f6c99fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ece7b7eb8f963efef648ed23f6c99fc">&#9670;&#160;</a></span>inside_sentence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::inside_sentence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether <em>iter</em> is inside a sentence (as opposed to in between two sentences, e.g. after a period and before the first letter of the next sentence). Sentence boundaries are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango text boundary algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is inside a sentence. </dd></dl>

</div>
</div>
<a id="a3cd86e2f7c6587a160d55530539a64e3" name="a3cd86e2f7c6587a160d55530539a64e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd86e2f7c6587a160d55530539a64e3">&#9670;&#160;</a></span>inside_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::inside_word </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether <em>iter</em> is inside a natural-language word (as opposed to say inside some whitespace). Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is inside a word. </dd></dl>

</div>
</div>
<a id="a03a307c658ba6004d08a3d448852187b" name="a03a307c658ba6004d08a3d448852187b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a307c658ba6004d08a3d448852187b">&#9670;&#160;</a></span>is_cursor_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::is_cursor_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classGtk_1_1TextIter.html#ac43e1833c36390271f139096f2246684">forward_cursor_position()</a> or Pango::LogAttr or pango_break() for details on what a cursor position is.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the cursor can be placed at <em>iter</em>. </dd></dl>

</div>
</div>
<a id="a4bc622b76b6d149cc8c162bea7f8a1ad" name="a4bc622b76b6d149cc8c162bea7f8a1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc622b76b6d149cc8c162bea7f8a1ad">&#9670;&#160;</a></span>is_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::is_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <em>iter</em> is the end iterator, i.e. one past the last dereferenceable iterator in the buffer. <a class="el" href="classGtk_1_1TextIter.html#a4bc622b76b6d149cc8c162bea7f8a1ad">is_end()</a> is the most efficient way to check whether an iterator is the end iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is the end iterator. </dd></dl>

</div>
</div>
<a id="adc36f98cd9d69a4afc6f89ba58808cbd" name="adc36f98cd9d69a4afc6f89ba58808cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc36f98cd9d69a4afc6f89ba58808cbd">&#9670;&#160;</a></span>is_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::is_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <em>iter</em> is the first iterator in the buffer, that is if <em>iter</em> has a character offset of 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> is the first in the buffer. </dd></dl>

</div>
</div>
<a id="aa7c9650c64751fe98aa235d9a49326f5" name="aa7c9650c64751fe98aa235d9a49326f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c9650c64751fe98aa235d9a49326f5">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gtk::TextIter::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for !is_end(). </p>

</div>
</div>
<a id="a945df1c0edb735d27c001d7588b10c70" name="a945df1c0edb735d27c001d7588b10c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945df1c0edb735d27c001d7588b10c70">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html#ae1f6efe5a5875e7198e3de43c64e2db0">value_type</a> Gtk::TextIter::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="classGtk_1_1TextIter.html#acf4a9e85bc094f7ed798b7b3491ddd92">get_char()</a>. </p>

</div>
</div>
<a id="a70482e3c658cb04b6ecad1ab612a9f35" name="a70482e3c658cb04b6ecad1ab612a9f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70482e3c658cb04b6ecad1ab612a9f35">&#9670;&#160;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp; Gtk::TextIter::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="classGtk_1_1TextIter.html#a46acea844c69273d92c63d910eca21c9">forward_char()</a>. </p>

</div>
</div>
<a id="ae27c3a2f0663071f9319fe140f047b72" name="ae27c3a2f0663071f9319fe140f047b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27c3a2f0663071f9319fe140f047b72">&#9670;&#160;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> Gtk::TextIter::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5e89f081569ca3a79b38ffc54d0bbc3" name="ae5e89f081569ca3a79b38ffc54d0bbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e89f081569ca3a79b38ffc54d0bbc3">&#9670;&#160;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp; Gtk::TextIter::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="classGtk_1_1TextIter.html#aeff64dab2ff97e06452f4ca7c030b758">backward_char()</a>. </p>

</div>
</div>
<a id="ae9050a524dda968db856b3e791fc833d" name="ae9050a524dda968db856b3e791fc833d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9050a524dda968db856b3e791fc833d">&#9670;&#160;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> Gtk::TextIter::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d3c25edf1efe92f5313ac740781238b" name="a4d3c25edf1efe92f5313ac740781238b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3c25edf1efe92f5313ac740781238b">&#9670;&#160;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>second</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the value of <em>first</em> and <em>second</em> if <em>second</em> comes before <em>first</em> in the buffer. That is, ensures that <em>first</em> and <em>second</em> are in sequence. Most text buffer functions that take a range call this automatically on your behalf, so there's no real reason to call it yourself in those cases. There are some exceptions, such as <a class="el" href="classGtk_1_1TextIter.html#aca810ca092905f0cc728f028be5a2f02">in_range()</a>, that expect a pre-sorted range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">second</td><td>Another <a class="el" href="classGtk_1_1TextIter.html">Gtk::TextIter</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfba7a50f3ec781d151cc5643e1b4083" name="abfba7a50f3ec781d151cc5643e1b4083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfba7a50f3ec781d151cc5643e1b4083">&#9670;&#160;</a></span>set_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_line </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves iterator <em>iter</em> to the start of the line <em>line_number</em>. If <em>line_number</em> is negative or larger than the number of lines in the buffer, moves <em>iter</em> to the start of the last line in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_number</td><td>Line number (counted from 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af63b8c2520413efdde54dd8ad5670579" name="af63b8c2520413efdde54dd8ad5670579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63b8c2520413efdde54dd8ad5670579">&#9670;&#160;</a></span>set_line_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_line_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byte_on_line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classGtk_1_1TextIter.html#a62c90b4327191537170c796a23d06b25">set_line_offset()</a>, but works with a <em>byte</em> index. The given byte index must be at the start of a character, it can't be in the middle of a UTF-8 encoded character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_on_line</td><td>A byte index relative to the start of <em>iter's</em> current line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62c90b4327191537170c796a23d06b25" name="a62c90b4327191537170c796a23d06b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c90b4327191537170c796a23d06b25">&#9670;&#160;</a></span>set_line_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_line_offset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>char_on_line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves <em>iter</em> within a line, to a new <em>character</em> (not byte) offset. The given character offset must be less than or equal to the number of characters in the line; if equal, <em>iter</em> moves to the start of the next line. See <a class="el" href="classGtk_1_1TextIter.html#af63b8c2520413efdde54dd8ad5670579">set_line_index()</a> if you have a byte index rather than a character offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">char_on_line</td><td>A character offset relative to the start of <em>iter's</em> current line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00ce173ce4d3622cc36e48d5bff2374f" name="a00ce173ce4d3622cc36e48d5bff2374f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ce173ce4d3622cc36e48d5bff2374f">&#9670;&#160;</a></span>set_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_offset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>char_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <em>iter</em> to point to <em>char_offset</em>. <em>char_offset</em> counts from the start of the entire text buffer, starting with 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">char_offset</td><td>A character number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40b3039e099a9c3d752b8a3809d1ae4d" name="a40b3039e099a9c3d752b8a3809d1ae4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b3039e099a9c3d752b8a3809d1ae4d">&#9670;&#160;</a></span>set_visible_line_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_visible_line_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byte_on_line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="classGtk_1_1TextIter.html#af63b8c2520413efdde54dd8ad5670579">set_line_index()</a>, but the index is in visible bytes, i.e. text with a tag making it invisible is not counted in the index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_on_line</td><td>A byte index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ccd69e5353e073ce841ff0e02ac6a7e" name="a7ccd69e5353e073ce841ff0e02ac6a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccd69e5353e073ce841ff0e02ac6a7e">&#9670;&#160;</a></span>set_visible_line_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TextIter::set_visible_line_offset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>char_on_line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="classGtk_1_1TextIter.html#a62c90b4327191537170c796a23d06b25">set_line_offset()</a>, but the offset is in visible characters, i.e. text with a tag making it invisible is not counted in the offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">char_on_line</td><td>A character offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad30723ef87da296d9033fc7f85792199" name="ad30723ef87da296d9033fc7f85792199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30723ef87da296d9033fc7f85792199">&#9670;&#160;</a></span>starts_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::starts_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <em>iter</em> begins a paragraph, i.e. if <a class="el" href="classGtk_1_1TextIter.html#ad2c6ca9348bb89f4e1f614954118f41b">get_line_offset()</a> would return 0. However this function is potentially more efficient than <a class="el" href="classGtk_1_1TextIter.html#ad2c6ca9348bb89f4e1f614954118f41b">get_line_offset()</a> because it doesn't have to compute the offset, it just has to see whether it's 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>iter</em> begins a line. </dd></dl>

</div>
</div>
<a id="a217523e50116ccaf23d276f422747d06" name="a217523e50116ccaf23d276f422747d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217523e50116ccaf23d276f422747d06">&#9670;&#160;</a></span>starts_sentence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::starts_sentence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether <em>iter</em> begins a sentence. Sentence boundaries are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango text boundary algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is at the start of a sentence. </dd></dl>

</div>
</div>
<a id="a1dd81e0a2658984f1bce0e2ce84121a6" name="a1dd81e0a2658984f1bce0e2ce84121a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd81e0a2658984f1bce0e2ce84121a6">&#9670;&#160;</a></span>starts_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::starts_word </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines whether <em>iter</em> begins a natural-language word. Word breaks are determined by Pango and should be correct for nearly any language (if not, the correct fix would be to the Pango word break algorithms).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>iter</em> is at the start of a word. </dd></dl>

</div>
</div>
<a id="a5bbe15539dfb50119b5b28b2155208c6" name="a5bbe15539dfb50119b5b28b2155208c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbe15539dfb50119b5b28b2155208c6">&#9670;&#160;</a></span>toggles_tag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::toggles_tag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e7e890f7a6cb3003c485e36b8eaad59" name="a0e7e890f7a6cb3003c485e36b8eaad59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7e890f7a6cb3003c485e36b8eaad59">&#9670;&#160;</a></span>toggles_tag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TextIter::toggles_tag </td>
          <td>(</td>
          <td class="paramtype">const Glib::RefPtr&lt; const <a class="el" href="classGtk_1_1TextTag.html">TextTag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is equivalent to (<a class="el" href="classGtk_1_1TextIter.html#a3f07a9e1606add1754568c80e4ac1a58">begins_tag()</a> || <a class="el" href="classGtk_1_1TextIter.html#a35645f29b1476ce8a7b899d343663e41">ends_tag()</a>), i.e. it tells you whether a range with <em>tag</em> applied to it begins <em>or</em> ends at <em>iter</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A <a class="el" href="classGtk_1_1TextTag.html">Gtk::TextTag</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>tag</em> is toggled on or off at <em>iter</em>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a0e373b53b974fbab36b1d45ebd206c76" name="a0e373b53b974fbab36b1d45ebd206c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e373b53b974fbab36b1d45ebd206c76">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a id="a1cdd13320f231bd906520131cdc138d2" name="a1cdd13320f231bd906520131cdc138d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdd13320f231bd906520131cdc138d2">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a id="a76f0b1315ba7b06bbdfbdd2e029bda73" name="a76f0b1315ba7b06bbdfbdd2e029bda73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f0b1315ba7b06bbdfbdd2e029bda73">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a id="a8703a159b88dc5e8dd8d4ea361667281" name="a8703a159b88dc5e8dd8d4ea361667281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8703a159b88dc5e8dd8d4ea361667281">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a id="ad50c7c8990fac0c51ac460034ff5f3c4" name="ad50c7c8990fac0c51ac460034ff5f3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50c7c8990fac0c51ac460034ff5f3c4">&#9670;&#160;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a id="a387ff6ec0c707b3a30ea7398cdc601d2" name="a387ff6ec0c707b3a30ea7398cdc601d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387ff6ec0c707b3a30ea7398cdc601d2">&#9670;&#160;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TextIter.html">TextIter</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

</div>
</div>
<a id="a5d77ba6925f3144ad49e36412791b7aa" name="a5d77ba6925f3144ad49e36412791b7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d77ba6925f3144ad49e36412791b7aa">&#9670;&#160;</a></span>wrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGtk_1_1TextIter.html">Gtk::TextIter</a> &amp; wrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
<a id="a5497a6a3458131b32c6aaa0fcab3f511" name="a5497a6a3458131b32c6aaa0fcab3f511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5497a6a3458131b32c6aaa0fcab3f511">&#9670;&#160;</a></span>wrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TextIter.html">Gtk::TextIter</a> &amp; wrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a533d80230ee6366bc575bed7369f4afb" name="a533d80230ee6366bc575bed7369f4afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533d80230ee6366bc575bed7369f4afb">&#9670;&#160;</a></span>gobject_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gtktexttag_8h.html#a1dba2dd8521aaf7299d5b3edba3bc429">GtkTextIter</a> Gtk::TextIter::gobject_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="textiter_8h_source.html#l00152">152</a> of file <a class="el" href="textiter_8h_source.html">textiter.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="textiter_8h_source.html">textiter.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceGtk.html">Gtk</a></li><li class="navelem"><a class="el" href="classGtk_1_1TextIter.html">TextIter</a></li>
    <li class="footer">Generated on Sat Aug 30 2025 20:23:23 for Ardour by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
